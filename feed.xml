<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xmlns:media="http://search.yahoo.com/mrss/">
    <title>Captain Embedded üë®üèª‚Äç‚úàÔ∏è‚öì</title>
    <link href="https://rosmianto.com/feed.xml" rel="self" />
    <link href="https://rosmianto.com" />
    <updated>2024-12-12T20:44:05+07:00</updated>
    <author>
        <name>Rosmianto A. Saputro</name>
    </author>
    <id>https://rosmianto.com</id>

    <entry>
        <title>How to work less (but with better result) as an embedded engineer</title>
        <author>
            <name>Rosmianto A. Saputro</name>
        </author>
        <link href="https://rosmianto.com/how-to-work-less-but-with-better-result-as-an-embedded-engineer.html"/>
        <id>https://rosmianto.com/how-to-work-less-but-with-better-result-as-an-embedded-engineer.html</id>
        <media:content url="https://rosmianto.com/media/posts/28/marvin-meyer-SYTO3xs06fU-unsplash.jpg" medium="image" />
            <category term="Embedded Career"/>

        <updated>2024-12-12T20:44:05+07:00</updated>
            <summary>
                <![CDATA[
                        <img src="https://rosmianto.com/media/posts/28/marvin-meyer-SYTO3xs06fU-unsplash.jpg" alt="" />
                    I'm an embedded systems engineer. The more I climb the corporate ladder, the more work I need to do. Partially&hellip;
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                    <p><img src="https://rosmianto.com/media/posts/28/marvin-meyer-SYTO3xs06fU-unsplash.jpg" class="type:primaryImage" alt="" /></p>
                <p>I'm an embedded systems engineer. The more I climb the corporate ladder, the more work I need to do.</p>
<p>Partially because the nature of work which is getting more and more complex, and requires high level of expertise.</p>
<p>And partially because the non-technical stuff like moving project target (very common in startup scenes), and having to cater multiple clients with overlapping features needs.</p>
<p>Not to mention that I'm also doing freelance work, consulting, <a href="https://www.linkedin.com/in/rosmianto/" target="_blank" rel="nofollow noopener noreferrer">creating content on LinkedIn</a>, and <a href="https://store.rosmianto.com/" target="_blank" rel="nofollow noopener noreferrer">writing books</a>. All of those require my attention and I only have 24 hours a day.</p>
<p>That's why I need to work¬†<em>less</em> while delivering result with higher quantity and quality.</p>
<p class="p1">Throughout¬†my embedded career, I've developed some techniques that worked for me. They've enabled me to do more meaningful work while deliberately <em>reduce</em> my effective working hours.</p>
<p>And just like any tips you found on the internet, steal what you like, and discard the rest.</p>
<h1>Automate everything you could</h1>
<p>Automation is a big part of my life as an embedded engineer, I try to automate everything as much as humanly possible to reduce tedious, repetitive, and boring tasks.</p>
<p>Just so you know, not everyhing worth automation, and it takes time to identify which is which. Here are some rules I use:</p>
<ol>
<li>If I do it almost every day (even multiple times a day), it's worth automate.</li>
<li>If I don't like the tasks, I will consider to automate it.</li>
<li>If I have the resources to make the system to offload the tasks, I will definitely consider automate.</li>
</ol>
<p>Using that rules, I can automate almost everything in my embedded workflow:</p>
<ul>
<li>Automate code typing using IntelliSense (in some cases, even using Gen AI)</li>
<li>Automate code formatting check using clang-format</li>
<li>Automate code checking by cppcheck</li>
<li>Automate code correctness by automated unit tests (I mostly use Catch2)</li>
<li>Automate code generation by using CubeMX (when working with STM32)</li>
<li>Automate firmware building using Makefile</li>
<li>Automate makefile generation using CMake</li>
<li>Automate code tracking using git</li>
<li>Automate code hosting using GitHub</li>
<li>Automate build process and binary generation using Docker + GitHub Actions</li>
<li>Automate docs generation using AI + Doxygen</li>
<li>Automate mock/stub generation using GMock and FakeIt</li>
<li>Automate code coverage checking using gcov</li>
</ul>
<p>Because the boring parts are now automated, now I can focus more on more important parts:</p>
<ul>
<li><a href="https://fwguide.rosmianto.com/" target="_blank" rel="noopener noreferrer">Firmware architecture design</a></li>
<li>Firmware design diagram</li>
<li>Making design decisions for our firmware development project</li>
<li>Discuss with stakeholders (CEO, CTO, Business team, clients) to gather project requirements in more detail</li>
</ul>
<h1>Ultra-tight feedback loop</h1>
<p>Feedback will ensure you're heading in the right path.</p>
<p>It's like arrow above your head on Crazy Taxi game.</p>
<p><img loading="lazy" src="https://shared.fastly.steamstatic.com/store_item_assets/steam/apps/71230/ss_5ddc57dd3e43d29787eceaf42e0e30a49419a371.600x338.jpg?t=1733765150" data-is-external-image="true"></p>
<p>Humans are full of blindspots, and feedback uncovers them. If somehow you are misguided, based on the feedback, you can realign so you can achieve your career goal faster.</p>
<p>So the cycle is clear: you work üëâ get feedback üëâ you improve üëâ you work üëâ get feedback.</p>
<p>It's a virtuous cycle, it's a positive feedback loop that will guarantee you career improvement. Combine that cycle with even tighter loop, you will get ultra-tight feedback loop.</p>
<p>Instead of getting feedback once every year, it's much better to get feedback every month. You know what's even better? Yes, getting feedback once every week, even daily.</p>
<p>Yes, daily feedback loop is all we need. It's impossible to fail if you realign with your career goal daily.</p>
<p>Sounds hard? Not really, the trick is you don't think getting feedback as something formal. It's the complete opposite, try to get feedback in casual settings, as often as possible, because casuality will make people more open, and thus giving more honest feedback of your work result, work ethics, work habits, etc.</p>
<p>Also, you don't wait until you are given feedback. Proactively ask for feedback. Here's how to effectively ask for feedback:</p>
<ul>
<li>After you finish your task (e.g. adding new features), you can immediately tag your senior/tech-lead on GitHub to ask for review. Personally ask "be brutally honest please"</li>
<li>At lunch time, strategically ask your colleagues/your direct report to sit at the same desk. Casually ask "what makes a good engineer in your opinion?"</li>
<li>If you have several senior engineers at your place, they are gems. Ask them by saying "teach me master" or "roast my code".</li>
</ul>
<p>The key is to keep things casual (not formal) because that's when people more open and honest to yourself (especially if you frame the questions like jokes).</p>
<h1>Exploit Parkinson's Law</h1>
<p>Parkinson's Law states that "<em>work expands to fill the available time</em>", which essentially means you will slack off when working on a job. If you allocate a task with 2 weeks deadline, it will be finished in 2 weeks. But if you allocate the same task with 2 days, then it will be finished in 2 days.</p>
<p>Obviously this law isn't hard science, it's an observation that people tends to procrastinate on their current tasks if there is no <em>sense</em> of urgency.</p>
<p>Fortunately, the opposite is also true. If you estimate the work can be done in 1 week, then try 1 day, and see how far you've gone. Just try it.</p>
<p>I once assigned to fix a 3-month bug, nobody had been able to solve that bug for months. The deadline was 1 month away. I don't know if I even could solve the bug, but I promise to myself I would solve it in 3-4 hours (stupid, I know).</p>
<p>I tried to solve it, found some patterns from my previous experience with lots of bugs. And I solved the bug in a day (10-hour session to be exact). I just solved a bug with 3 months deadline within a day. I got paid $1000 for solving that bug.</p>
<p>Here's the method to exploit Parkinson's Law. I call it: <strong>The Time Compression</strong> method.</p>
<p>Just like data compression, you compress time by encoding information more efficiently than the original format. Here's how:</p>
<p>Step 1: <strong>Identify Patterns</strong>. Just like Redudancy Detection in data compression, you need to identify recurring, tedious, boring, low-value tasks and see if they can be either grouped together, delegated, or deleted.</p>
<p>Step 2: <strong>Prioritize High-value tasks first</strong>. Which is the equivalent of Symbol Weighting in data compression algorithm. After you identify patterns, you sort the tasks, and immediately target the high-impact tasks first. Instead of building PCB straight from the requirements, why not create a prototype first on breadboard? Ensure the GPIO pins are all compatible, ensure the I2C sensors are working, try to find potential issues first like testing if the flash memory you're using is fast enough for your project (just an example).</p>
<p>Step 3: <strong>Find a better way to do things</strong>. If you know some action can lead to faster result, even though it means you need to learn something, then do it immediately. The payoff is doubled here: 1. You learn something new, 2. You solved the problem much faster.</p>
<p>Here's a concrete, real-life example: I was working on GPS tracking device at work. Obviously GPS will need to be outdoor to work normally. Problem is, I work with my PC to develop the firmware and troubleshoot issues, flashing firmware, monitoring log output, and it's indoor, so you can imagine the problem already.</p>
<p>The distance was 30 meters between my PC and the GPS, ideally I would need a USB extender to make it work. I didn't have one so I need to back and forth bring the GPS device inside to check the log and update firmware.</p>
<p>Totally inefficient. I have wide WiFi coverage, only if I can piggyback the USB packets via WiFi. And that's when I discovered USB-IP, a USB passthrough over IP. I learned a bit to setup (probably like 1 hour max). Connect a random Raspberry Pi (any raspi will do, including Zero Wireless) to the GPS device, and I can immediately access the device as if it was connected directly to my PC locally.</p>
<figure class="post__image post__image--center"><img loading="lazy"  src="https://rosmianto.com/media/posts/28/usbip.png" alt="" width="691" height="81" sizes="(min-width: 37.5em) 1600px, 80vw" srcset="https://rosmianto.com/media/posts/28/responsive/usbip-xs.png 384w ,https://rosmianto.com/media/posts/28/responsive/usbip-sm.png 600w ,https://rosmianto.com/media/posts/28/responsive/usbip-md.png 768w ,https://rosmianto.com/media/posts/28/responsive/usbip-lg.png 1200w ,https://rosmianto.com/media/posts/28/responsive/usbip-xl.png 1600w"></figure>
<p>Instead of waiting for 3 days and wasting $20 for a 30-meter USB extender for this specific case, I used what I had, and I found a better way to do my things.¬†</p>
<p>Sometimes Step 3 is closely related to automation, well because one better way to do things is really by automating it. Another example is my little tool here:</p>
<figure ><figure class="post__image post__image--center"><img loading="lazy"  src="https://rosmianto.com/media/posts/28/photo_2024-09-16-14.05.01-2.jpeg" alt="" width="500" height="585" sizes="(min-width: 37.5em) 1600px, 80vw" srcset="https://rosmianto.com/media/posts/28/responsive/photo_2024-09-16-14.05.01-2-xs.jpeg 384w ,https://rosmianto.com/media/posts/28/responsive/photo_2024-09-16-14.05.01-2-sm.jpeg 600w ,https://rosmianto.com/media/posts/28/responsive/photo_2024-09-16-14.05.01-2-md.jpeg 768w ,https://rosmianto.com/media/posts/28/responsive/photo_2024-09-16-14.05.01-2-lg.jpeg 1200w ,https://rosmianto.com/media/posts/28/responsive/photo_2024-09-16-14.05.01-2-xl.jpeg 1600w"></figure>
<figcaption >A simple electronic load with logging capability</figcaption>
</figure>
<p>At work, my company bought several solar panels with different sizes and powers. I was asked to characterize each solar panels and get the IV curve for each. Something like this:</p>
<figure ><figure class="post__image post__image--center"><img loading="lazy"  src="https://rosmianto.com/media/posts/28/and-P-V-curves-of-a-photovoltaic-module.png" alt="" width="500" height="237" sizes="(min-width: 37.5em) 1600px, 80vw" srcset="https://rosmianto.com/media/posts/28/responsive/and-P-V-curves-of-a-photovoltaic-module-xs.png 384w ,https://rosmianto.com/media/posts/28/responsive/and-P-V-curves-of-a-photovoltaic-module-sm.png 600w ,https://rosmianto.com/media/posts/28/responsive/and-P-V-curves-of-a-photovoltaic-module-md.png 768w ,https://rosmianto.com/media/posts/28/responsive/and-P-V-curves-of-a-photovoltaic-module-lg.png 1200w ,https://rosmianto.com/media/posts/28/responsive/and-P-V-curves-of-a-photovoltaic-module-xl.png 1600w"></figure>
<figcaption >IV curve for finding maximum power point of a solar panel (credit: Ababacar Ndiaye)</figcaption>
</figure>
<p>Essentially I need to measure the voltage output while varying the load. To make the load variable, I need to use many power resistor with different values. Just imagine how tedious the task would be.</p>
<p>And this is another perfect example of automation. Instead of naively buy loads of resistors, and test one by one, I went another route: I build a dedicated electronic load which logs the current and voltage output.</p>
<p>I probably spent around 3-4 hours building it. But the ROI was priceless.</p>
<p>In summary, Parkinson's Law can do bad or good for you, depending how you use it. Exploit the law by using Time Compression I've outlined above.</p>
<h1>Delegate your work (even as an engineer)</h1>
<p>Let's be honest, life as an engineer is full of tasks:</p>
<ul>
<li>Writing documentation</li>
<li>Meeting to discuss ideas for new project</li>
<li>Gathering project requirements to answer business problem</li>
<li>Exploring the best technology to solve the problem</li>
<li>Selecting components, reaching out to vendors, calls with Field Engineers</li>
<li>Writing and testing firmware code</li>
<li>Coordinating with many stakeholders to ensure smooth development</li>
<li>Etc.</li>
</ul>
<p>Ah, too many. I'm even too lazy to list them all. You know me. And here's one recipe to ensure your life will be miserable:</p>
<p>Do it everything yourself.</p>
<p>Busy is good. But if you're too busy, that means you're worthless and inefficient (especially if you sacrifice family time, personal time, and prayer time).</p>
<p>Look, if there's too much on your plate, this means you need to offload your tasks. In other words, you need to delegate¬†<em>some</em> of your work.</p>
<p>I understand that your boss delegates some of his/her tasks to you, but that doesn't mean you can't delegate your tasks. Here's what I mean:</p>
<p>If you pay a closer attention, you'll notice that some of your tasks is high-value but tedious, like thinking about what features an embedded project should have.</p>
<p>Or what chip to use, etc.</p>
<p>Realize that you can delegate those tasks to the most capable machine to work on those: generative AI.</p>
<p>Yes, I said it. Things like ChatGPT, Claude, Perplexity, Gemini. They are can help you automate most of tasks that require low creativity, but high precisions.</p>
<p>For example, if I want to build a GPS tracker for heavy machinery, what standard features should I implement?</p>
<p>I can list them all by myself like:</p>
<ul>
<li>Able to track GPS coordinate</li>
<li>Able to send data via LoRaWAN</li>
<li>Able to store data in case of poor signal quality</li>
<li>Able to store configuration</li>
</ul>
<p>And the list goes on. There's a high chance I would miss some important features, well because I'm still a human.</p>
<p>Now, let's ask AI to help us do it:</p>
<figure class="post__image post__image--center"><img loading="lazy"  src="https://rosmianto.com/media/posts/28/Screenshot-2024-12-11-at-09.09.18.png" alt="" width="640" height="268" sizes="(min-width: 37.5em) 1600px, 80vw" srcset="https://rosmianto.com/media/posts/28/responsive/Screenshot-2024-12-11-at-09.09.18-xs.png 384w ,https://rosmianto.com/media/posts/28/responsive/Screenshot-2024-12-11-at-09.09.18-sm.png 600w ,https://rosmianto.com/media/posts/28/responsive/Screenshot-2024-12-11-at-09.09.18-md.png 768w ,https://rosmianto.com/media/posts/28/responsive/Screenshot-2024-12-11-at-09.09.18-lg.png 1200w ,https://rosmianto.com/media/posts/28/responsive/Screenshot-2024-12-11-at-09.09.18-xl.png 1600w"></figure>
<p>Here's the raw output from my ChatGPT:</p>
<blockquote>
<p>Building a GPS tracker for heavy machinery requires attention to durability, precision, and functionality tailored to the operational needs of construction, mining, and agricultural equipment. Here are the <strong>standard features</strong> you should implement:</p>
<h3><strong>Core Features</strong></h3>
<ol>
<li>
<p><strong>Real-Time Location Tracking</strong></p>
<ul>
<li>Use GPS/GLONASS/Galileo/Beidou for accurate global positioning.</li>
<li>Update intervals should be configurable (e.g., every 10 seconds to every few minutes).</li>
</ul>
</li>
<li>
<p><strong>Geofencing</strong></p>
<ul>
<li>Allow users to set virtual boundaries.</li>
<li>Trigger alerts when the machinery leaves or enters a specified area.</li>
</ul>
</li>
<li>
<p><strong>Activity Monitoring</strong></p>
<ul>
<li>Track engine runtime, idle time, and operational hours.</li>
<li>Provide insights into machine usage and efficiency.</li>
</ul>
</li>
<li>
<p><strong>Anti-Theft Alerts</strong></p>
<ul>
<li>Tamper detection (e.g., vibration or physical removal alert).</li>
<li>Movement detection when the machine is supposed to be stationary.</li>
</ul>
</li>
<li>
<p><strong>Durable Design</strong></p>
<ul>
<li>Rugged, waterproof, and dustproof casing (e.g., IP67 or higher).</li>
<li>Vibration and shock resistance to withstand harsh environments.</li>
</ul>
</li>
<li>
<p><strong>Remote Immobilization</strong></p>
<ul>
<li>Enable operators to remotely disable the machinery in case of theft or unauthorized use.</li>
</ul>
</li>
<li>
<p><strong>Power Supply and Backup</strong></p>
<ul>
<li>Connect to the heavy machinery's power source.</li>
<li>Include a rechargeable battery with sufficient backup (e.g., 24‚Äì48 hours) in case of disconnection.</li>
</ul>
</li>
<li>
<p><strong>Data Logging</strong></p>
<ul>
<li>Store data locally when the cellular signal is lost and sync it once the connection is restored.</li>
<li>Include non-volatile memory to prevent data loss during power outages.</li>
</ul>
</li>
<li>
<p><strong>Connectivity</strong></p>
<ul>
<li><strong>Cellular Connectivity</strong>: Support 2G/3G/4G LTE and future-proofing for 5G.</li>
<li><strong>Satellite Communication</strong> (optional): For remote areas without cellular coverage.</li>
<li><strong>Bluetooth/Wi-Fi</strong>: For close-range configuration and firmware updates.</li>
</ul>
</li>
<li>
<p><strong>Over-the-Air (OTA) Updates</strong></p>
<ul>
<li>Allow remote firmware and software updates.</li>
</ul>
</li>
</ol>
<hr>
<h3><strong>Advanced Features</strong></h3>
<ol>
<li>
<p><strong>Sensor Integration</strong></p>
<ul>
<li>Accelerometers and gyroscopes for motion, tilt, and vibration monitoring.</li>
<li>Temperature, humidity, and fuel sensors for environmental and operational monitoring.</li>
</ul>
</li>
<li>
<p><strong>Route Optimization</strong></p>
<ul>
<li>Provide insights into optimal routes for heavy machinery movement.</li>
</ul>
</li>
<li>
<p><strong>Driver Behavior Monitoring</strong></p>
<ul>
<li>Track metrics like harsh braking, sharp turns, and over-speeding.</li>
</ul>
</li>
<li>
<p><strong>Predictive Maintenance</strong></p>
<ul>
<li>Integrate with CAN bus or OBD-II to monitor engine health and notify users of potential issues.</li>
</ul>
</li>
<li>
<p><strong>Dashboards and Reporting</strong></p>
<ul>
<li>Provide a web or mobile app for tracking, analytics, and reporting.</li>
<li>Generate automatic reports (e.g., daily, weekly, or monthly usage summaries).</li>
</ul>
</li>
<li>
<p><strong>Multi-Device Support</strong></p>
<ul>
<li>Track and manage multiple pieces of machinery from a single interface.</li>
</ul>
</li>
</ol>
<hr>
<h3><strong>Compliance Features</strong></h3>
<ol>
<li>
<p><strong>Regulatory Compliance</strong></p>
<ul>
<li>Ensure compliance with relevant regulations (e.g., emissions, safety, or transport laws) in the target region.</li>
</ul>
</li>
<li>
<p><strong>Audit Trail</strong></p>
<ul>
<li>Keep logs of operational data for legal or maintenance purposes.</li>
</ul>
</li>
</ol>
<hr>
<h3><strong>Additional Considerations</strong></h3>
<ul>
<li><strong>Energy Efficiency</strong>: Ensure the tracker consumes minimal power from the machinery.</li>
<li><strong>Localization</strong>: Support multiple languages and units of measurement for global users.</li>
<li><strong>Scalability</strong>: Design the system to support fleets of various sizes.</li>
</ul>
<p>By focusing on these features, you can create a reliable GPS tracker that meets the specific demands of heavy machinery operations while offering value through advanced monitoring and management capabilities.</p>
</blockquote>
<p>I'm not even thinking about geofencing and Anti-theft alert. But there are many good features to know.</p>
<p>Now, I don't have to implement everything, I have the list, and know I just choose what I need to answer the business problem, and I'll propose it to my boss.</p>
<p>Yes, the answer isn't complete. For example, I need it to be configurable, but I can always ask a follow-up request to chatGPT to breakdown the settings I need to have (interval settings, LoRaWAN OTAA or ABP, timeout settings, etc.)</p>
<p>This is just one example.</p>
<p>Another example is to delegate program writing to AI, especially if the program is very simple. I love to use AI to generate Python script utilities to help me finish my job.</p>
<p>I once needed to log a 24-hour UART output to analyze bugs, I need a customized program to store the log into a file with specific naming rules. I know I could write a python script myself, but instead I just delegated it to chatGPT.</p>
<p>It generated the script python, but when I reviewed the code, there's some minor issues. I told ChatGPT to change some part of the code and the result was a robust, and good enough Python script to get things done.</p>
<p><strong>Tips</strong>: Don't ask ChatGPT something you can't verify or correct. Think of it like an internship student who knows theory, but lack of practical experience and wisdom.</p>
<p>If you don't know how to write firmware, don't ask ChatGPT to generate firmware.</p>
<p>If you don't know legal clause, don't ask it to generate legal agreement document.</p>
<p>Remember, generative AI is there to help you accelerate tasks you already know how to do it, not tasks you know nothing about. Because in my observation, many beginners (ab)used gen AI and treat it like a demigod who knows all. And blindly copy and follow every output it spitted. Not a good way to use AI.</p>
<h1>Quantity over quality</h1>
<p>To work less as an embedded engineer, you need to do quality job at work.</p>
<p>But, unless you're learning about fitness and gym, at the beginning you need quantity over quality.</p>
<p>As a beginner learning something new, forget about quality. You don't know what defines quality so you be better off by doing quantity first. Do it enough time until to get the sense of "best" way to achieve the goal.</p>
<p>And here's a secret: you do quality at work, and you do quantity at home.</p>
<p>Yes, that's the irony of working less. You essentially work more <em>outside your job</em>, so you can work less at workplace.</p>
<p>Just remember Tiger Wood, the golf champion. He had practiced 5-figure hours before he even became the world champion. He would practice his swings, his pose, his mentality¬†<em>outside¬†</em>competitions, not¬†<em>inside¬†</em>competitions.</p>
<p>Your "golf competition" is your workplace, and your practice sessions are <em>outside of it.</em></p>
<h1>Exposure to lots of things</h1>
<p>Lastly, what you truly need to work less is actually know how to do your job. Yeah I know it sounds meh, but here me out.</p>
<p>When you first do anything, you will be suck. Because you need to get to know the topic, you need to familiarize yourself with the relevant tools, you need to understand the core concepts. All of those are important when you're working as an embedded engineer.</p>
<p>For example, first time you learn CAN bus, everything is hard:</p>
<ul>
<li>You need to understand what is CAN bus, and where it's used</li>
<li>You need to understand the core concepts of CAN bus, the signalling system, the protocol</li>
<li>You need to learn the CAN bus transceiver chips, probably you have to read the entire datasheet</li>
<li>You need to learn the tools to analyze CAN data, and how to troubleshoot them</li>
<li>etc.</li>
</ul>
<p>As you begin to be familiar with the CAN bus workflow, you begin to see patterns, and next time you're tasked to work on CAN bus, everything feels easy.</p>
<p>Remember, the CAN bus is still the same, but somehow, something that was hard, now is easy peasy. Hard knowledge about CAN stays unchanged, it's your brain that grows.</p>
<p>Now, imagine you're hanging out with your fellow engineer friends every weekend. Imagine last weekend you both talked about his work, about modbus.</p>
<p>Your friend started to blabber about modbus, whining about bugs and issues, and because you were curious, you asked him about modbus, what's the difference between modbus vs CAN bus, and how did he solve the bugs he was facing.</p>
<p>He told you everything he knows, the basic concepts, the tools, the mechanisms. And you started to get familiar with modbus, although you have never touch modbus project before.</p>
<p>Next month, your company announced that they are starting to use modbus for your embedded project. <strong>Bingo!</strong></p>
<p>You are given 1 month to learn modbus and write firmware for the prototype. Guess what? You probably don't need 1 month to finish, probably 1 week is more realistic, because all the most important parts (aka the foundational) has been learned (thanks to your friend).</p>
<p>Imagine: 1 month down to 1 week. That's a <strong>400%</strong> acceleration.</p>
<p>What do you do in week 2 and so on? You tell me. I don't and won't dictate what you should do (Hint: learn something that will propel your career even further).¬†</p>
<p>Now, exposure can be in many forms:</p>
<ul>
<li>From your hangout friends (like above)</li>
<li>From your weekend reading</li>
<li>From your side project experiments</li>
<li><a href="https://freelancer.rosmianto.com/" target="_blank" rel="noopener noreferrer">From doing freelance work</a></li>
</ul>
<p>From those options, the last one is interesting. Because by doing freelance work, the benefit is twofolds now: 1. You are learning something new. 2. You get paid.</p>
<p>The more exposure you get, the easier it is to work on pretty much any topics. Because embedded is an industry with strong hands-on requirement, the more your hand gets dirty, the faster you can work, thus making yourself far more efficient at workplace.</p>
<p>Get ready to be promoted, because from my experience, companies reward those who can showcased lightning-fast learning speed. Your influence will be higher, people are seeking your advice, and beware, you will attract haters too! (office politics are always an ugly thing, you know).</p>
<p>That's all you need to know to work less as an embedded engineer.</p>
<p>Remember, working less doesn't mean you're lazy. In fact, it's the complete opposite. Ability to work less means you're¬†<em>efficient</em>, and by being efficient you can tackle more harder problems and solve more high-impact problem in your life, and at your workplace.</p>
<p>Personally I prefer being more efficient at work, because that way, I don't need to worry about overtime, struggle finding basic knowledge, etc. Thus saving my energy after work. I'm married with one 3 year-old son, so I would rather play with him instead of spending more hours at work, doing things I should be delegated, compress, or delete.</p>
<p>¬†</p>
            ]]>
        </content>
    </entry>
    <entry>
        <title>Want to Switch Career to Embedded Systems? Use JUMP Framework</title>
        <author>
            <name>Rosmianto A. Saputro</name>
        </author>
        <link href="https://rosmianto.com/want-to-switch-career-to-embedded-systems-use-jump-framework.html"/>
        <id>https://rosmianto.com/want-to-switch-career-to-embedded-systems-use-jump-framework.html</id>
        <media:content url="https://rosmianto.com/media/posts/27/alex-radelich-2gYsZUmockw-unsplash.jpg" medium="image" />
            <category term="Embedded Career"/>

        <updated>2024-08-26T08:21:05+07:00</updated>
            <summary>
                <![CDATA[
                        <img src="https://rosmianto.com/media/posts/27/alex-radelich-2gYsZUmockw-unsplash.jpg" alt="" />
                    Switching career is a big decision. Probably you've had enough with your current job, your current company, or more generally&hellip;
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                    <p><img src="https://rosmianto.com/media/posts/27/alex-radelich-2gYsZUmockw-unsplash.jpg" class="type:primaryImage" alt="" /></p>
                <p>Switching career is a big decision.</p>
<p>Probably you've had enough with your current job, your current company, or more generally your current industry.</p>
<p>Then you start to think about switching careers.</p>
<p>Maybe you like doing programming and hardware, but for some reason, you had to enter a different industry.</p>
<p>I 100% understand. Because life must go on, there are bills to pay, there's family to feed.</p>
<p>But as you really think about it, you start to ask "<em>Is embedded system worth the jump?</em>"</p>
<p>That's a valid and real question. And because it's often a big decision to make, I want to help you make an informed decision. That's why I created this framework to help you do exactly that.</p>
<p>It's called JUMP Framework:</p>
<ul>
<li><strong>J</strong>ustify your switch</li>
<li><strong>U</strong>nderstand the embedded systems' career building blocks</li>
<li><strong>M</strong>ake a solid transition plan</li>
<li><strong>P</strong>repare for interview</li>
</ul>
<p>At the end of this article, I hope I can help you make a better decision. Now, let's dive right into each point.</p>
<h1>Justify Your Switch</h1>
<p>You need to be aware of why you want to switch. And why Embedded Systems specifically.</p>
<p>If the answer is money, I don't think you should make the jump.</p>
<p>Look. Salary, wage, paycheck, is a relative measure. Here's the truth:</p>
<ul>
<li>You can be highly paid as an embedded engineer</li>
<li>You can be underpaid as an embedded engineer</li>
<li>You can be highly paid as a data scientist</li>
<li>You can also be underpaid as a data scientist</li>
</ul>
<p>I know too many cases. The point is, if your main motivation is money, you should be aware that being an embedded engineer doesn't automatically guarantee you a better income (though it can be a rewarding career).</p>
<p>Sometimes your motive is because you're bored with your current job? Then you can actually do embedded systems on the side, even <a href="https://freelancer.rosmianto.com/">become an embedded freelancer</a>. No need to jump career.</p>
<p>Maybe your true love is hardware and firmware? Maybe. But are you ready to survive the entire process and restart your career?</p>
<p>I'm sorry if I sounded like to discourage you from making the jump. Well, it's because switching career is risky, it's a big decision. Especially if you're a highly qualified employee in another industry (like 5+ years of experience in another industry).</p>
<p>You will restart your career, your salary, your skills.</p>
<p>But if you can justify the jump (which is often pretty personal and subjective), I'm glad to get a new embedded system friend.</p>
<p>If that's the case, let's jump to the next point.</p>
<h1>Understand the embedded systems' career building blocks</h1>
<p>Now, because you're committed to making the switch. I have a moral obligation to equip you with proper foundational knowledge and skills. But just like anything in this world, learning embedded systems takes time. You need to be familiar with the building blocks of embedded systems career.</p>
<p>To successfully work on Embedded Systems, you actually need 3 main skills:<br><br>üëâ Computer Science<br>üëâ Electrical Engineering<br>üëâ A third¬†<span class="text-primary font-bold">field</span>¬†depending on your interest</p>
<figure class="post__image post__image--center"><img loading="lazy"  src="https://rosmianto.com/media/posts/27/venn.avif" alt="" width="430" height="406"></figure><br>We need CS because there are programming aspects in Embedded Systems. We have to create robust, and efficient code for the device.<br><br>We need EE because we will be interfacing with electronic devices like sensors and actuators.<br><br>Understanding the electronics under the hoods will make your life as an Embedded Engineer easy.<br><br>Lastly, we need a third¬†<span class="text-primary font-bold">field</span>. It means that if we work on embedded devices on vehicles then we need to learn and understand automotive: its standards, the rules, the principles in auto.<br><br>The same with other¬†<span class="text-primary font-bold">field</span>s.<br><br>Personally I was working in mining and marine, so I needed to learn and understand how mining processes are done, how harsh the environment is, etc.</p>
<h1>Make a solid transition plan</h1>
<p>If you want to switch careers, chances are, you already have valuable skills under your belt.</p>
<p>For example, if you are a data scientist. You can exploit the data analysis (in case you work with sensor data), data processing and signal processing, etc.</p>
<p>If you are an AI/ML engineer, you can exploit your AI/ML knowledge and pair it with embedded building blocks above and you will make a solid embedded AI engineer.</p>
<p>If you are a web developer, that's even easier. You have plenty of software design experience, software architecture skills (which is highly valuable in embedded systems), basically you will need to go lower level than the web.</p>
<p>What you need to focus on is your¬†<em><strong>transferrable skills</strong></em>. Focus on those, and pair them with the building blocks concept (EE + CS + third field). After that, you want to go deeper and <a href="https://fw101.rosmianto.com/">familiarize yourself with some embedded systems concepts</a>.</p>
<h1>Prepare for interview</h1>
<p>Lastly, you want to be employed as an embedded systems engineer. Obviously you will need to apply for a job, and prepare for the interview.</p>
<p>Interview processes are different from company to company, but what you really need to focus on is your hands-on experience, because embedded systems is essentially an industry with heavy hands-on focus.</p>
<p>Sometimes you will have to do a technical interview to assess your technical skills. That's why I strongly recommend you <a href="https://rosmianto.com/how-i-created-100-embedded-side-projects-with-examples.html">build side projects as many as possible</a>.</p>
<p>Or, alternatively, if you don't want to be a full-time employee, you might <a href="https://rosmianto.com/how-to-do-freelancing-as-an-embedded-engineer.html">want to do freelancing</a>. It's probably a safer bet for you before you fully commit to being an embedded engineer.¬†</p>
<h1>Wrapping It Up</h1>
<p>That's all.</p>
<p>Again, switching careers can be risky, so you need a better plan to mitigate the risk.</p>
<p>Planning can't be understated. You need to have strong reasons, you have to understand and be familiar with the embedded systems concepts, you have to prepare.</p>
<p>If you are 100% sure, I wish you 100% success! And JUMP to embedded systems world!</p>
            ]]>
        </content>
    </entry>
    <entry>
        <title>The Snake-Game Test üêç</title>
        <author>
            <name>Rosmianto A. Saputro</name>
        </author>
        <link href="https://rosmianto.com/the-snake-game-test.html"/>
        <id>https://rosmianto.com/the-snake-game-test.html</id>
        <media:content url="https://rosmianto.com/media/posts/26/albert-XRhu6Ux1iNA-unsplash.jpg" medium="image" />
            <category term="Embedded Tips"/>

        <updated>2024-08-25T13:52:54+07:00</updated>
            <summary>
                <![CDATA[
                        <img src="https://rosmianto.com/media/posts/26/albert-XRhu6Ux1iNA-unsplash.jpg" alt="" />
                    This is my favorite way to learn embedded systems: The Snake-Game Test. When we‚Äôre learning any topic in embedded systems,&hellip;
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                    <p><img src="https://rosmianto.com/media/posts/26/albert-XRhu6Ux1iNA-unsplash.jpg" class="type:primaryImage" alt="" /></p>
                <p>This is my favorite way to learn embedded systems:</p>
<p>The Snake-Game Test.</p>
<p>When we‚Äôre learning any topic in embedded systems, what really important is the relevance between what we know vs. what we can do.</p>
<p>That‚Äôs why hands-on experiment is extremely important in embedded systems.</p>
<p>The Snake-Game Test is a simple test to check if we do enough hands-on when learning embedded system. It‚Äôs an interesting framework to help you ensure you don‚Äôt waste time learning unnecessary things.</p>
<p>The Snake-Game Test was inspired by me when I was trying to build a snake game using C++.</p>
<p>When I was building the game, I didn't learn the entire C++ language constructs, but I only learned what I needed to build the snake game.</p>
<p>That approach gave me a better understanding of basic game design, and basic C++ constructs. I always know if I want to learn more advanced C++ features, then I can learn it by building even more complex programs.</p>
<p>Here are the 4 foundational concepts of The Snake-Game Test:</p>
<ol>
<li>Real-World Project</li>
<li>Just-In-Time learning</li>
<li>Extremely Hands-On</li>
<li>Iteratively Improve the Project</li>
</ol>
<p>Let's dive right into each concept.</p>
<h1>Real-World Project</h1>
<p>If what you do is hypothetical projects like foobar, building linked list, etc. You'll struggle to apply the topic you're learning.</p>
<p>Instead, pick a real-world project, that's concrete enough for you to work on, like the Snake game. Everyone has played snake game at some point in their life.</p>
<p>Instead of writing program with 1000 linked-list, why not create a snake-game¬†<em><strong>that applies linked-list concept to the snake?</strong></em></p>
<h1>Just-In-Time Learning</h1>
<p>Instead of learning everything upfront (which takes too much time), The Snake-Game Framework encourages you to learn just enough to make the project work.</p>
<p>Instead of learning every C++ feature from a book, learn just enough to make the snake move. Start by asking questions:</p>
<ul>
<li>Snake usually moves in grid, how to implement grid system in C++?</li>
<li>How do I actually¬†<em>draw</em> image using C++?</li>
<li>How to make the snake move? What data structure to use?</li>
<li>How to place snake's food at random places?</li>
<li>How to detect the snake biting itself?</li>
<li>Etc.</li>
</ul>
<p>By answering the questions above, you are guaranteed to learn and use only the important things of C++ for the snake game.</p>
<p>Another example, let's say you want to learn MQTT and decide to build a temperature monitoring system. You don't read the source code of HiveMQ Broker. Instead, you ask these questions:</p>
<ul>
<li>What is MQTT? How can I send data from A to B?</li>
<li>What is MQTT Topic? What is QoS? What's the difference?</li>
<li>Should I write my own client or is there ready-to-use library for MQTT?</li>
<li>etc.</li>
</ul>
<p>That way, you won't overwhelm yourself with the complexity of MQTT broker source code. You will have good experience and great understanding of the basics.</p>
<h1>Extremely Hands-On</h1>
<p>We're not doing theoretical study here.</p>
<p>We're not analyzing the game design mechanics, reward system, level-up mechanism, etc. We want to build the damn snake-eating-food game until it dies.</p>
<p>We're not writing an essay on how MQTT actually sends and transmits data.</p>
<p>We're not writing an essay comparing MQTT vs. HTTP vs. WebSocket.</p>
<p>We're building something. Period.</p>
<p>Yes, you might have to research a bit, but the goal is to assist you in building the project, not writing essay.</p>
<h1>Iterative Approach</h1>
<p>The Snake-Game Framework encourages iterative process.</p>
<p>First, you make the program draw grid. No snake yet? No problem.</p>
<p>Second, you make the program render the snake. No foods yet? No problem.</p>
<p>Third, you make the snake move and add food. Buggy? Good. Fix it.</p>
<p>Next, you start adding wall detection, self-bite detection, etc.</p>
<p>The point is, nobody is watching you, so you might want to make as many stupid mistakes as humanly possible (you will be surprised how many recompilations I did just to fix a simple bug).</p>
<p>This Snake-Game Test (probably I should call it "framework") will <strong>help you close the gap between what you know vs. what you can do</strong>.</p>
<p>Happy learning! üêç</p>
<p><!-- notionvc: 341f702b-7600-4fac-8e06-459ae9cecf46 --></p>
            ]]>
        </content>
    </entry>
    <entry>
        <title>6 Strategies for Learning ESP-IDF (without going insane)</title>
        <author>
            <name>Rosmianto A. Saputro</name>
        </author>
        <link href="https://rosmianto.com/strategies-for-learning-esp-idf-and-not-going-insane.html"/>
        <id>https://rosmianto.com/strategies-for-learning-esp-idf-and-not-going-insane.html</id>
        <media:content url="https://rosmianto.com/media/posts/24/kevin-ku-w7ZyuGYNpRQ-unsplash.jpg" medium="image" />
            <category term="Embedded Tips"/>

        <updated>2024-06-24T12:06:33+07:00</updated>
            <summary>
                <![CDATA[
                        <img src="https://rosmianto.com/media/posts/24/kevin-ku-w7ZyuGYNpRQ-unsplash.jpg" alt="" />
                    If you try to write firmware for ESP32 microcontroller, you will have two popular choices: Arduino is easier. And you&hellip;
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                    <p><img src="https://rosmianto.com/media/posts/24/kevin-ku-w7ZyuGYNpRQ-unsplash.jpg" class="type:primaryImage" alt="" /></p>
                <p>If you try to write firmware for ESP32 microcontroller, you will have two popular choices:</p>
<ol>
<li>Arduino framework</li>
<li>ESP-IDF</li>
</ol>
<p>Arduino is easier. And you probably have good experience with AVR-based Arduino boards (like UNO, Nano, Mega2560, etc.), so writing firmware for ESP32 using Arduino is seamless.</p>
<p>You already know the basics.</p>
<p>But because Arduino framework is designed to be simple, lots of concepts are hidden from you. When you work with a slightly more complex project, you will quickly realize that Arduino won't cut it.</p>
<p>For example, let's say you want to build a BLE scanner using ESP32.</p>
<p>The goal is simple: to scan nearby BLE devices as fast as possible, if the scanning process is too slow, you will miss some BLE devices. It's often required if you want to track BLE device movements.</p>
<p>Now, you can scan BLE devices using Arduino framework, yes. But it will be noticeably slower. So, there's no other choice: use ESP-IDF for better performance.</p>
<p>However, using ESP-IDF is not without downsides. Just take a look at this code comparison below:</p>
<figure ><figure class="post__image post__image--center"><img loading="lazy"  src="https://rosmianto.com/media/posts/24//Konthen.drawio.png" alt="" width="1000" height="664" sizes="(min-width: 37.5em) 1600px, 80vw" srcset="https://rosmianto.com/media/posts/24//responsive/Konthen.drawio-xs.png 384w ,https://rosmianto.com/media/posts/24//responsive/Konthen.drawio-sm.png 600w ,https://rosmianto.com/media/posts/24//responsive/Konthen.drawio-md.png 768w ,https://rosmianto.com/media/posts/24//responsive/Konthen.drawio-lg.png 1200w ,https://rosmianto.com/media/posts/24//responsive/Konthen.drawio-xl.png 1600w"></figure>
<figcaption >Left: Arduino code. Right: ESP-IDF example code for ADC</figcaption>
</figure>
<p>Both essentially do the same thing: sample analog signal, and printout the value.</p>
<p>But the right side is hard to follow, especially if you're not familiar with ESP-IDF. There are too many things to unpack here:</p>
<ul>
<li>Okay I know ADC. But what's that <em>oneshot</em> thing?</li>
<li>What ESP_ERROR_CHECK will do?</li>
<li>Why ADC needs calibration?</li>
<li>Wait, there are TWO ADCs inside ESP32?</li>
<li>Why there's so many #include?</li>
<li>Why it's called vTaskDelay() and not just delay()?</li>
</ul>
<p>You see, there are many concepts hidden in Arduino framework. No wonder people said they struggle to learn ESP-IDF.</p>
<p>So, I will share with you my 6 strategies (plus 1 bonus strategy) to learn ESP-IDF without going insane.</p>
<h1>Strategy #1: Hone Your C Skill, Especially Function Pointer and Callback</h1>
<p>ESP-IDF is written in C. It's actually a good thing because as a framework, it should ensure interoperability with many other languages. C is the lowest common denominator for embedded programming.</p>
<p>ESP-IDF can be sometimes heavy on OOP concepts, and because it's written in C, the framework uses lots of function pointers and callback and pass-by-reference to mimic C++ OOP.</p>
<p>You can be confused if you don't understand the basics of function pointer and callback in C.</p>
<h1>Strategy #2: Think in Subsystem, not Linear Thinking</h1>
<p>I'm sorry for saying jargon.</p>
<p>Basically by thinking in subsystem, you focus your attention on different parts of the system and how all those parts interact and influence each other.</p>
<p>Linear thinking is when you think step-by-step, like BASIC or Assembly programming. It's procedural thinking.</p>
<p>ESP-IDF can sometimes be heavy on event-driven as well. So System thinking will be extremely helpful for you. Now let me give you an example.</p>
<p>Let's check the ESP-IDF example code for WiFi:</p>
<figure class="post__image post__image--center"><img loading="lazy"  src="https://rosmianto.com/media/posts/24/Screenshot-2024-06-23-at-15.33.43.png" alt="" width="1000" height="465" sizes="(min-width: 37.5em) 1600px, 80vw" srcset="https://rosmianto.com/media/posts/24/responsive/Screenshot-2024-06-23-at-15.33.43-xs.png 384w ,https://rosmianto.com/media/posts/24/responsive/Screenshot-2024-06-23-at-15.33.43-sm.png 600w ,https://rosmianto.com/media/posts/24/responsive/Screenshot-2024-06-23-at-15.33.43-md.png 768w ,https://rosmianto.com/media/posts/24/responsive/Screenshot-2024-06-23-at-15.33.43-lg.png 1200w ,https://rosmianto.com/media/posts/24/responsive/Screenshot-2024-06-23-at-15.33.43-xl.png 1600w"></figure>
<p>it's just a code to initialize the ESP32 WiFi to act as an Access Point.</p>
<p>Notice that ugly <code>esp_event_handler_instance_register</code> function?</p>
<p>It's responsible for adding event handling to the API. Whenever the WiFi state changes (like something connected, or disconnected), the function <code>wifi_event_handler</code> (the callback function) will be called later. And here is the function implementation:</p>
<figure class="post__image post__image--center"><img loading="lazy"  src="https://rosmianto.com/media/posts/24/Screenshot-2024-06-23-at-15.37.35.png" alt="" width="1000" height="352" sizes="(min-width: 37.5em) 1600px, 80vw" srcset="https://rosmianto.com/media/posts/24/responsive/Screenshot-2024-06-23-at-15.37.35-xs.png 384w ,https://rosmianto.com/media/posts/24/responsive/Screenshot-2024-06-23-at-15.37.35-sm.png 600w ,https://rosmianto.com/media/posts/24/responsive/Screenshot-2024-06-23-at-15.37.35-md.png 768w ,https://rosmianto.com/media/posts/24/responsive/Screenshot-2024-06-23-at-15.37.35-lg.png 1200w ,https://rosmianto.com/media/posts/24/responsive/Screenshot-2024-06-23-at-15.37.35-xl.png 1600w"></figure>
<p>Don't worry about those alien macros and structs yet.</p>
<p>Now, the question is. When exactly this function will be executed? Like how many seconds after bootup?</p>
<p>The answer is we don't know. It's the nature of event-driven programming. The function will only be executed only if the WiFi state is changed.</p>
<p>That's why we can't rely on <strong>l</strong><strong>inear thinking</strong>, because we would be confused as hell. With <strong>system</strong> <strong>thinking</strong>, we will understand that the WiFi event will interact with our <code>wifi_event_handler</code> function <em>later</em>.</p>
<p>ESP-IDF has an insanely large amount of event-driven programming, especially if you work with WiFi and Bluetooth.</p>
<p>So, force yourself really hard in system thinking, not procedural/linear thinking.</p>
<h1>Strategy #3: Use VSCode 'Goto Definition' Feature</h1>
<p>ESP-IDF encapsulates many data formats and structures inside <code>struct</code>, and sometimes we want to know the full structure of the datatype. Look at this GPIO example code:</p>
<figure class="post__image post__image--center"><img loading="lazy"  src="https://rosmianto.com/media/posts/24/Screenshot-2024-06-24-at-11.22.20.png" alt="" width="476" height="314" sizes="(min-width: 37.5em) 1600px, 80vw" srcset="https://rosmianto.com/media/posts/24/responsive/Screenshot-2024-06-24-at-11.22.20-xs.png 384w ,https://rosmianto.com/media/posts/24/responsive/Screenshot-2024-06-24-at-11.22.20-sm.png 600w ,https://rosmianto.com/media/posts/24/responsive/Screenshot-2024-06-24-at-11.22.20-md.png 768w ,https://rosmianto.com/media/posts/24/responsive/Screenshot-2024-06-24-at-11.22.20-lg.png 1200w ,https://rosmianto.com/media/posts/24/responsive/Screenshot-2024-06-24-at-11.22.20-xl.png 1600w"></figure>
<p>If I want to know the exact structure of <code>gpio_config_t</code>, I could look it up from the documentation, but that's tedious!</p>
<p>Instead, I just right-click it and select 'Goto Definition'. It's enough for me to understand the data structure. But if I want more explanation, then I'll go to the official docs.</p>
<figure class="post__image post__image--center"><img loading="lazy"  src="https://rosmianto.com/media/posts/24/Screenshot-2024-06-24-at-11.24.22.png" alt="" width="423" height="397" sizes="(min-width: 37.5em) 1600px, 80vw" srcset="https://rosmianto.com/media/posts/24/responsive/Screenshot-2024-06-24-at-11.24.22-xs.png 384w ,https://rosmianto.com/media/posts/24/responsive/Screenshot-2024-06-24-at-11.24.22-sm.png 600w ,https://rosmianto.com/media/posts/24/responsive/Screenshot-2024-06-24-at-11.24.22-md.png 768w ,https://rosmianto.com/media/posts/24/responsive/Screenshot-2024-06-24-at-11.24.22-lg.png 1200w ,https://rosmianto.com/media/posts/24/responsive/Screenshot-2024-06-24-at-11.24.22-xl.png 1600w"></figure>
<p>That way, I'll understand the API context much easier and faster.</p>
<h1>Strategy #4: Go back to the theory!</h1>
<p>I'll admit, the reason why ESP-IDF seems hard to learn is because <em>it's actually more complex</em>. And by more complex, I mean the framework doesn't hide many details in the code (unlike Arduino framework).</p>
<p>Even if we open the example code, it still feels overwhelming.</p>
<p>Remember, ESP-IDF provides¬†<em><strong>example</strong> </em><strong>projects</strong>, not¬†<em><strong>tutorials</strong></em><em>.¬†</em>Mind the difference!</p>
<p>The goal is to provide as many details as possible, covering many use cases. Not being tutorials, ESP-IDF expects you to be familiar with lots of terms before.</p>
<p>For example, just open the example code for BLE. It's complex:</p>
<figure class="post__image post__image--center"><img loading="lazy"  src="https://rosmianto.com/media/posts/24/Screenshot-2024-06-24-at-11.39.17.png" alt="" width="643" height="326" sizes="(min-width: 37.5em) 1600px, 80vw" srcset="https://rosmianto.com/media/posts/24/responsive/Screenshot-2024-06-24-at-11.39.17-xs.png 384w ,https://rosmianto.com/media/posts/24/responsive/Screenshot-2024-06-24-at-11.39.17-sm.png 600w ,https://rosmianto.com/media/posts/24/responsive/Screenshot-2024-06-24-at-11.39.17-md.png 768w ,https://rosmianto.com/media/posts/24/responsive/Screenshot-2024-06-24-at-11.39.17-lg.png 1200w ,https://rosmianto.com/media/posts/24/responsive/Screenshot-2024-06-24-at-11.39.17-xl.png 1600w"></figure>
<p>What you see above is the parameter for <em>BLE payload advertisement</em>.</p>
<p>Confused with BLE advertisement? Why would the BLE device advertise something?</p>
<p>You won't understand the code if you don't understand the theory behind BLE standard. There are tons of terms and jargon, so you need to be familiar with:</p>
<ul>
<li>BLE advertisements</li>
<li>BLE scanning</li>
<li>GATT profile</li>
<li>BLE Services</li>
<li>BLE architecture</li>
<li>BLE software stack (nimble vs. Bluedroid)</li>
<li>etc.</li>
</ul>
<p>If you work with ADC, then you need to understand first:</p>
<ul>
<li>Different types of ADC (SAR, Sigma-Delta, Dual-slope ADC, etc.)</li>
<li>Bit-width</li>
<li>Sampling rate</li>
<li>Sampling mode (continuous vs. oneshot)</li>
<li>ADC resolution and accuracy</li>
<li>Quantization</li>
<li>Reference Voltage</li>
<li>Calibration and compensation (temperature etc.)</li>
</ul>
<p>If you never heard most of the concepts above, no wonder you will struggle to understand ESP-IDF because it assumes you're already familiar with them.</p>
<p>So, go back to your textbooks and reference manuals from major semiconductor vendors.</p>
<h1>Strategy #5: Don't Create Project from Scratch, Copy from Example Code Instead</h1>
<p>Building firmware is hard enough, so don't torture yourself by creating projects from scratch.</p>
<p>Use example code. Pick one that's closest to your needs. For example, if you want to create firmware to interface I2C EEPROM, don't write from zero. ESP-IDF already provides that.</p>
<p>Use it.</p>
<p>ESP-IDF license should be good for you to copy their code (It's not legal advice though).</p>
<h1>Strategy #6: Read ESP-IDF docs over and over again</h1>
<p>This is the most obvious tip.</p>
<p>You need to read the documentation over and over again.</p>
<p>Because first read you won't understand a thing.</p>
<p>But second read you will pick up some more details.</p>
<p>The third read you will understand the context and the nuance.</p>
<p>The fourth read you're already familiar where to look for extra details.</p>
<p>The fifth read you will become more and more comfortable with the ESP-IDF inside out.</p>
<p><em><strong>But that requires time!</strong></em></p>
<p>Duh? In which world learning doesn't require time?</p>
<h1>Bonus Strategy: Learn FreeRTOS concepts</h1>
<p>This is probably an underrated strategy.</p>
<p>You should understand that ESP-IDF uses FreeRTOS APIs almost all the time.</p>
<p>So, you need to also familiar with FreeRTOS concepts to understand ESP-IDF code.</p>
<ul>
<li>Task management (creation, delete, suspend, resume)</li>
<li>Queue</li>
<li>Semaphore</li>
<li>Mutex</li>
<li>Event Group</li>
<li>Notification</li>
<li>etc.</li>
</ul>
<p>Good luck with learning ESP-IDF!</p>
<p>¬†</p>
            ]]>
        </content>
    </entry>
    <entry>
        <title>Transitioning from Arduino to STM32? There Are Some Caveats You Should Know</title>
        <author>
            <name>Rosmianto A. Saputro</name>
        </author>
        <link href="https://rosmianto.com/transitioning-from-arduino-to-stm32-there-are-some-caveats-you-should-know.html"/>
        <id>https://rosmianto.com/transitioning-from-arduino-to-stm32-there-are-some-caveats-you-should-know.html</id>
        <media:content url="https://rosmianto.com/media/posts/23/8olf2u-2.jpg" medium="image" />
            <category term="Embedded Productivity"/>

        <updated>2024-05-02T12:11:14+07:00</updated>
            <summary>
                <![CDATA[
                        <img src="https://rosmianto.com/media/posts/23/8olf2u-2.jpg" alt="" />
                    You've learned Arduino and feel confident with your basic embedded skills. Now you want to upgrade yourself by learning STM32.
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                    <p><img src="https://rosmianto.com/media/posts/23/8olf2u-2.jpg" class="type:primaryImage" alt="" /></p>
                <p>You've learned Arduino and feel confident with your basic embedded skills. Now you want to upgrade yourself by learning STM32. It should be the next logical step, right?</p>
<p>First of all, I want to say congratulations to you because you've proved yourself that you enjoy embedded systems. Not many people can go through that phase.</p>
<p>Now, this is the new phase. Learning something more "serious" like STM32. (though you can seriously use Arduino as well, <a href="https://rosmianto.com/yes-you-can-use-arduino-for-commercial-grade-only-if-you-do-this.html" target="_blank" rel="noopener noreferrer">with some tips</a>).</p>
<p>I promise you, learning STM32 will be a delightful experience, and you won't regret a single bit (pardon the pun). But to ensure the smoothest transition, I will offer you some of my wisdom.</p>
<figure class="post__image post__image--center" ><img loading="lazy" src="https://rosmianto.com/media/posts/23//8olf2u.jpg" alt="" width="521" height="323" sizes="(min-width: 37.5em) 1600px, 80vw" srcset="https://rosmianto.com/media/posts/23//responsive/8olf2u-xs.jpg 384w ,https://rosmianto.com/media/posts/23//responsive/8olf2u-sm.jpg 600w ,https://rosmianto.com/media/posts/23//responsive/8olf2u-md.jpg 768w ,https://rosmianto.com/media/posts/23//responsive/8olf2u-lg.jpg 1200w ,https://rosmianto.com/media/posts/23//responsive/8olf2u-xl.jpg 1600w">
<figcaption >If you watched Avatar Aang, please read my tips using Roku's voice.</figcaption>
</figure>
<p>There are several things you need to know to ensure a smooth transition (not as smooth as butter though, you still have to learn a lot):</p>
<div class="post__toc">
<h3>¬†</h3>
<ul>
<li><a href="#mcetoc_1hsp0ir5s46">Which STM32 board should you choose?</a></li>
<li><a href="#mcetoc_1hsp0ir5s47">To maximize learning, don't use Arduino framework</a></li>
<li><a href="#mcetoc_1hsp0ir5s48">CMSIS, HAL, mbed, Keil, IAR, CubeMX. What the hell are they?</a></li>
<li><a href="#mcetoc_1hsp0ir5s49">Different way to configure peripherals</a></li>
<li><a href="#mcetoc_1hsp0ir5s4a">Different build system (and flags)</a></li>
<li><a href="#mcetoc_1hsp0ir5s4b">Different library structure</a></li>
<li><a href="#mcetoc_1hsp0ir5s4c">More debugging feature</a></li>
</ul>
</div>
<p>¬†</p>
<p>Let's dive into each point.</p>
<h1 id="mcetoc_1hsp0ir5s46">Which STM32 board should you choose?</h1>
<p>If you just want to pick one board. Choose the blue pill. That's it. It's good enough for you to get started. Blue pill means the STM32 board's form-factor is like a giant pill and the color is blue.</p>
<p>Usually blue pills contain <strong>STM32F103</strong> microcontroller which is pretty good for various basic projects.</p>
<figure class="post__image post__image--center" ><img loading="lazy" src="https://rosmianto.com/media/posts/23/STM32F103C8T6_Blue_Pill-4-2.jpg" alt="" width="539" height="359" sizes="(min-width: 37.5em) 1600px, 80vw" srcset="https://rosmianto.com/media/posts/23/responsive/STM32F103C8T6_Blue_Pill-4-2-xs.jpg 384w ,https://rosmianto.com/media/posts/23/responsive/STM32F103C8T6_Blue_Pill-4-2-sm.jpg 600w ,https://rosmianto.com/media/posts/23/responsive/STM32F103C8T6_Blue_Pill-4-2-md.jpg 768w ,https://rosmianto.com/media/posts/23/responsive/STM32F103C8T6_Blue_Pill-4-2-lg.jpg 1200w ,https://rosmianto.com/media/posts/23/responsive/STM32F103C8T6_Blue_Pill-4-2-xl.jpg 1600w">
<figcaption >The Blue Pill with STM32F103 microcontroller. Image: stm32-base.org</figcaption>
</figure>
<p>Of course you can pick other boards. For example, if you want to focus on low-power project (aka battery-powered), you can explore STM32L series. Personally I'd go with L0 series (e.g. <strong>STM32L072</strong>) if I want to squeeze battery life, but with the cons being slower and not suitable for high-computing projects.</p>
<p>If I need more performance, I'd go with the L4 series (e.g. <strong>STM32L476</strong>). It has Floating-Point Unit (FPU) and larger memory. Great for projects like smartwatch. I have a project where I need to perform 1000 float/double calculations per second on the fly. L0 won't cut it. L4 series will crush this requirement.</p>
<p>You probably won't need more powerful boards right now. But if you do need some inspiration, you could use H5 or H7 series if you're doing crazy stuff like high-speed DSP, or AI/ML stuff.</p>
<p>But again, if you're just starting out the Blue Pill will do just fine.</p>
<h1 id="mcetoc_1hsp0ir5s47">To maximize learning, don't use Arduino framework</h1>
<p>Yes, you read that right. Though I have no issue if you use Arduino framework professionally, I think you should ditch Arduino framework this time.</p>
<blockquote>
<p>Wait, you could use Arduino framework with Blue Pill?</p>
<p>Yes. Search "STM32duino".</p>
</blockquote>
<p>Because you have used Arduino board like UNO or Pro or Micro before, you definitely have used Arduino framework (you know, if you used <code>Serial.begin(115200)</code> before, it's Arduino framework).</p>
<p>STM32 microcontroller is way too powerful compared to basic ATMega328 chip.</p>
<p>Arduino, in your case, will hinder your learning progress and will hide too many interesting features an STM32 microcontroller has to offer.</p>
<h1 id="mcetoc_1hsp0ir5s48">CMSIS, HAL, mbed, Keil, IAR, CubeMX. What the hell are they?</h1>
<p>They are tools and libraries in STM32 ecosystem.</p>
<p>ARM (the company) created ARM Cortex-M (the processor) and wrote libraries for it and call it <strong>CMSIS</strong>.</p>
<p>ST Microelectronics created microcontrollers (like STM32F103) and used Cortex-M as the processor. ST then wrote libraries for STM32F103 and called it <strong>HAL</strong> (on top of the CMSIS).</p>
<p><strong>mbed</strong> is ARM (the company) version of Arduino framework, it's far more powerful than Arduino. You probably want to get experience on HAL first, then if you're interested, you could try mbed.</p>
<p>Now, your firmware source code needs to be compiled so you can get the binary and flash it into the microcontroller. There are many options you can take:</p>
<ul>
<li>GCC Compiler. Free, but not too optimized for STM32 microcontroller.</li>
<li>IAR Compiler. Optimized binary result, but paid or limited feature in free version.</li>
<li>Keil Compiler. Also optimized and limited feature in free version.</li>
</ul>
<p>Pick GCC, it should enough for now. As you gain more experience and knowledge, you probably want to switch to IAR or Keil offering.</p>
<p>ST Microelectronics offers a tool called <strong>STM32CubeMX</strong> to generate a boilerplate (template project for you to get started).</p>
<p>Why would you need a boilerplate? Because STM32 microcontrollers have tons of peripherals, and each of them has tons of configuration. It's tedious and painful to write code manually over and over again, so ST created a tool to assist you generating the basic code.</p>
<h1 id="mcetoc_1hsp0ir5s49">Different way to configure peripherals</h1>
<p>I'd say it again, STM32 microcontrollers have tons of peripherals, and each of them has tons of configuration. Let me give you an example:</p>
<p>In STM32, you will find something called <strong>Clock Tree</strong>.</p>
<p>Unlike your classic ATMega328 which uses a single clock for the entire chip, STM32 can have different clock speeds for each of its peripherals. Why you might ask? In summary it's for flexibility.</p>
<figure class="post__image post__image--center" ><img loading="lazy" src="https://rosmianto.com/media/posts/23/Screenshot-2024-05-02-at-08.32.18.png" alt="" width="651" height="294" sizes="(min-width: 37.5em) 1600px, 80vw" srcset="https://rosmianto.com/media/posts/23/responsive/Screenshot-2024-05-02-at-08.32.18-xs.png 384w ,https://rosmianto.com/media/posts/23/responsive/Screenshot-2024-05-02-at-08.32.18-sm.png 600w ,https://rosmianto.com/media/posts/23/responsive/Screenshot-2024-05-02-at-08.32.18-md.png 768w ,https://rosmianto.com/media/posts/23/responsive/Screenshot-2024-05-02-at-08.32.18-lg.png 1200w ,https://rosmianto.com/media/posts/23/responsive/Screenshot-2024-05-02-at-08.32.18-xl.png 1600w">
<figcaption >The Clock Tree. STM32 even have 2 crystals with different frequencies (left blue boxes).</figcaption>
</figure>
<p>Now, configuring clock tree is error-prone when it's done manually, that's why we use CubeMX to help us generate correct settings for the entire system.</p>
<p>This is drastically different in Arduino, where we simply use <code>Serial.begin()</code> for UART peripheral, <code>SPI.begin()</code> for the SPI, and so on. Because the configuration is simple, we can do it in a single line. No need to have CubeMX for Arduino.</p>
<p>This is something you need to be aware of when exploring STM32. You will need CubeMX almost all the time.</p>
<p>I said this so you won't be surprised with the tooling.</p>
<h1 id="mcetoc_1hsp0ir5s4a">Different build system (and flags)</h1>
<p>In Arduino, usually we just click a button to compile the source code and flash binary to the board. We don't really care about the process. What we expect is to just get the board flashed.</p>
<p>Although we can automate the build process in STM32, we will have to make effort to understand the build system. For example, you need to understand linker script, CMake script, what files to compile, etc.</p>
<p>In Arduino you can't set the compile and linking flags. Heck, we don't even understand what is compiler "flags". Yes, it's an important topic but Arduino hides them from us.</p>
<p>Actually this topic alone is worth a book chapter, and I won't go deeper here. I'm just giving you a caution so you won't discouraged when things are getting harder (because it will be harder).</p>
<h1 id="mcetoc_1hsp0ir5s4b">Different library structure</h1>
<p>This is probably the most difficult thing to accept as someone transitioning from Arduino to STM32.</p>
<p>Arduino libraries have their own structure and way of operating. And they are, in general, not compatible with STM32 ecosystem (except someone has ported the libs).</p>
<p>For example, <a href="https://github.com/adafruit/Adafruit_SSD1306" target="_blank" rel="noopener noreferrer">this OLED display library</a> cannot directly be used for STM32 HAL. You need to port it manually (which requires some skills).</p>
<p>Some libraries are platform-independent, this is the kind of library I love. Some examples are <a href="https://github.com/mikalhart/TinyGPSPlus" target="_blank" rel="noopener noreferrer">TinyGPS</a> (with minor modifications), <a href="https://github.com/bblanchon/ArduinoJson" target="_blank" rel="noopener noreferrer">ArduinoJSON</a>, and <a href="https://github.com/boschsensortec/BMI160_SensorAPI" target="_blank" rel="noopener noreferrer">Bosch BMI160 driver</a> (not beginner-friendly though). So I can use them pretty much without much changes to use for my STM32 HAL projects.</p>
<p>So embrace the fact you will find yourself writing (or porting) driver for anything not Arduino compatible.</p>
<h1 id="mcetoc_1hsp0ir5s4c">More debugging feature</h1>
<p>In STM32 you will get more advanced debugging options: JTAG, SWD, as well as the classic printf().</p>
<p>The cool thing about advanced debugging is you can gain much deeper information about the <strong><em>system state</em></strong>. It's just a fancy word to describe current memory condition. You can see every variable's content, what functions are being called, what caused crash, how much memory a task consumes, etc.</p>
<p>You cannot do that using Arduino.</p>
<p>But for every advanced technology, there is always an additional effort to understand and use it.</p>
<p>So, make the effort and learn them.</p>
<p>There you have it. Happy learning STM32!</p>
<p>¬†</p>
            ]]>
        </content>
    </entry>
    <entry>
        <title>How I Created 100 Embedded Side Projects (With Examples)</title>
        <author>
            <name>Rosmianto A. Saputro</name>
        </author>
        <link href="https://rosmianto.com/how-i-created-100-embedded-side-projects-with-examples.html"/>
        <id>https://rosmianto.com/how-i-created-100-embedded-side-projects-with-examples.html</id>
        <media:content url="https://rosmianto.com/media/posts/22/hunter-haley-s8OO2-t-HmQ-unsplash.jpg" medium="image" />
            <category term="Embedded Productivity"/>

        <updated>2024-04-29T21:35:21+07:00</updated>
            <summary>
                <![CDATA[
                        <img src="https://rosmianto.com/media/posts/22/hunter-haley-s8OO2-t-HmQ-unsplash.jpg" alt="" />
                    The fastest way to 10x your embedded learning progress is by building tons of side projects. I'd say you should&hellip;
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                    <p><img src="https://rosmianto.com/media/posts/22/hunter-haley-s8OO2-t-HmQ-unsplash.jpg" class="type:primaryImage" alt="" /></p>
                <p>The fastest way to 10x your embedded learning progress is by building <a href="https://rosmianto.com/2-rule-method-for-experimental-projects.html" target="_blank" rel="noopener noreferrer">tons of side projects</a>. I'd say you should aim for at least 100 side projects.</p>
<p>Don't worry about quality, just build tons of crappy craps. Because your mission isn't to build world-class firmware, but to learn the basics, the nuance, the context of embedded development.</p>
<p>Now, you might ask "<em>100 is a big number, how the hell I could produce that much? What should I build?"</em></p>
<p>Well, first of all. You are absolutely right. 100 projects is¬†<em>plenty</em>. But you don't actually build them in a week. I built them for years, in my spare time.</p>
<p>And regarding what you should build, here are 3 ways of doing it:</p>
<ol>
<li>Use Google and Pinterest (search "<em>embedded project ideas</em>", and see what you like to build)</li>
<li>Use ChatGPT (prompt "<em>I'm a junior/senior engineer with X years of experience looking for project ideas. My interest is low-power project, list 20 project ideas, be concise</em>")</li>
<li>Or, my personal way of doing it: Project Stacking Method</li>
</ol>
<h1>Use My Way: Project Stacking Method</h1>
<p>Project Stacking Method is just some method I randomly invented. Basically <em>you don't build random projects, but build a new project based on your previous projects</em>.</p>
<p>Confused? Let me explain.</p>
<p>I will start by asking myself this question: <em>what's the embedded-equivalent of "hello world"?</em> The answer is obviously blinking LED.</p>
<h2>Project #1: Blinking an LED</h2>
<p>Okay, that's my first side project, just blinking an LED.</p>
<p>By building this project, I learned how to create a simple sketch using Arduino, how to pick the right current-limiting resistor for the LED, lastly I learned that delay() will determine the blinking frequency of my LED. Good and simple enough.</p>
<p><strong><em>"Oh come on Ross, blinking LED is toooo easy. I need more advanced topics."</em></strong></p>
<p>If you think that's too simple (which is true btw). Let's create another project.</p>
<p>I will ask myself: <em>If I can build an LED to blink, how can I build a "breathing" LED?</em></p>
<h2>Project #2: A Fading LED</h2>
<p>Yes, breathing LED is called fading LED. By building this project, I learned that fading LED can't use simple GPIO toggle which is digital. I need¬†<em>analog signal</em>.</p>
<p>How do I generate analog signal using Arduino? I found out that PWM is the answer.</p>
<p>I just stacked my fading LED project on top my blinking LED. This is interesting because I now can adjust the brightness of my LED.</p>
<p><em><strong>More complexity please!</strong></em>¬†</p>
<p>I will then ask: wait, my LED is just a single color. How can I fade an RGB LED?</p>
<p><strong>Project #3: A fading RGB LED</strong>. Wait, RGB is fascinating. I want moreeee.</p>
<p><strong>Project #4: 3 fading RGB LEDs</strong>. Haha this is fun. I want 8 RGB LEDs.</p>
<p><strong>Project #5: 8 fading RGB LEDs</strong>. Well, this is getting complex. Not enough PWM pins, so I need to use shift-registers to control all 24 signal pins. I learned much about bit serialization, register concepts. I guess I'm ready for more complex project.</p>
<p><strong>Project #6: 8x8 fading RGB LEDs</strong>. Oh my goddd, this is getting out of hand. Now I need to be careful with the timing, and memory management. I need to pump out the serialized bits fast enough to make it good. I had enough LED project.</p>
<p><strong>Project #7: Connecting microcontroller to network via WiFi</strong>. Okay, this is interesting. I will probably use ESP32. You know what, I think I want to control those 8x8 fading RGB LEDs using my smartphone.</p>
<p><strong>Project #8: Controlling 8x8 RGB LEDs via WiFi</strong>. I learned how to use MQTT to exchange data.</p>
<p>Keep doing projects until <strong>Project #100</strong>.</p>
<p>You see, I build a project based on my previous project. Sometimes I had enough and decided to explore another interest (WiFi), and suddenly I can stack the existing projects (#6 and #7). Making it far more challenging than a simple blinking LED.</p>
<p>To use Project Stacking Method, you will need to hone your curiosity. Let your curiosity define your path and see what you can do with it.</p>
<p>Project Stacking Method isn't just for beginners trying to learn basic embedded concepts, it's also applicable to any level, including senior engineers. Though the topics will be very very different.</p>
<p>For example, seniors can do project like "<em>self-healing mesh network using Zigbee</em>". Or "<em>100% heapless C++ firmware development</em>". Or maybe "<em>AI-enabled smart home system where the AI can suggest electric bills optimization by observing usage pattern</em>" (okay I'm getting crazy here, but you got the idea).</p>
<p>I've been doing it for years, and my limitation now is actually time, not ideas. I'm married with one toddler son, so you probably understand how tricky it is to split time to work on side projects.</p>
<p>But if you have plenty of free time, you should really exploit it before you're getting married haha. üòÅ</p>
<p>PS: Send me a DM if you build a project. Probably I can give you my perspectives.</p>
<p>¬†</p>
            ]]>
        </content>
    </entry>
    <entry>
        <title>6 Real-World Embedded Projects to Learn From (Warning! Not For Beginners)</title>
        <author>
            <name>Rosmianto A. Saputro</name>
        </author>
        <link href="https://rosmianto.com/6-real-world-embedded-projects-to-learn-from-warning-not-for-beginners.html"/>
        <id>https://rosmianto.com/6-real-world-embedded-projects-to-learn-from-warning-not-for-beginners.html</id>
        <media:content url="https://rosmianto.com/media/posts/21/Screenshot-2024-04-06-at-20.49.23-2.png" medium="image" />
            <category term="Embedded Tips"/>

        <updated>2024-04-06T21:26:41+07:00</updated>
            <summary>
                <![CDATA[
                        <img src="https://rosmianto.com/media/posts/21/Screenshot-2024-04-06-at-20.49.23-2.png" alt="" />
                    Building real-world embedded products is hard. By real-world, I mean things you could use every day. Not some hackish product&hellip;
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                    <p><img src="https://rosmianto.com/media/posts/21/Screenshot-2024-04-06-at-20.49.23-2.png" class="type:primaryImage" alt="" /></p>
                <p>Building real-world embedded products is hard.</p>
<p>By real-world, I mean things you could use every day. Not some hackish product or just a Proof-of-Concept</p>
<p>I admit, it's hard because:<br><br>üëâ We don't know how to develop serious hardware design<br>üëâ We don't know how to write serious firmware<br>üëâ We don't know how to make a sleek enclosure<br>üëâ We lack of examples<br><br>That's why we need to look at how real-world projects are built.<br><br>The problem is, such projects are not easy to find.<br><br>Fortunately, I collect real-world projects like rich people collect watches.<br><br>Here are 6 real-world projects you could explore and learn, so you can understand the complexity of real-world projects.</p>
<h1>Numworks</h1>
<p>Numworks is a graphing calculator with sleek design and cool UI. The company released both the hardware and the firmware to make the product. It used by many students around the world.</p>
<figure class="post__image post__image--center"><img loading="lazy"  src="https://rosmianto.com/media/posts/21/Screenshot-2024-04-06-at-20.43.39.png" alt="" width="517" height="314" sizes="(min-width: 37.5em) 1600px, 80vw" srcset="https://rosmianto.com/media/posts/21/responsive/Screenshot-2024-04-06-at-20.43.39-xs.png 384w ,https://rosmianto.com/media/posts/21/responsive/Screenshot-2024-04-06-at-20.43.39-sm.png 600w ,https://rosmianto.com/media/posts/21/responsive/Screenshot-2024-04-06-at-20.43.39-md.png 768w ,https://rosmianto.com/media/posts/21/responsive/Screenshot-2024-04-06-at-20.43.39-lg.png 1200w ,https://rosmianto.com/media/posts/21/responsive/Screenshot-2024-04-06-at-20.43.39-xl.png 1600w"></figure>
<p>The device used to be hackable, meaning you could update the firmware to modify its features and capability (it has STM32 MCU so plenty of crazy stuff can be made).</p>
<p>Unfortunately, many schools and universities forbid hackable calculator (to prevent cheating), so Numworks company make it super-hard to update firmware.</p>
<p>But still, it's a cool project, I learned tons of electronics and firmware design from it. <a href="https://www.numworks.com/engineering/" target="_blank" rel="noopener noreferrer">Open here to view their tech specs, hardware, and software</a>.</p>
<h1>Clockwork GameShell</h1>
<p>GameShell is an open-source portable game console. It has a powerful specs. If you like playing Gameboy Advance, you will like it too.</p>
<figure class="post__image post__image--center"><img loading="lazy"  src="https://rosmianto.com/media/posts/21/Screenshot-2024-04-06-at-20.49.23.png" alt="" width="582" height="338" sizes="(min-width: 37.5em) 1600px, 80vw" srcset="https://rosmianto.com/media/posts/21/responsive/Screenshot-2024-04-06-at-20.49.23-xs.png 384w ,https://rosmianto.com/media/posts/21/responsive/Screenshot-2024-04-06-at-20.49.23-sm.png 600w ,https://rosmianto.com/media/posts/21/responsive/Screenshot-2024-04-06-at-20.49.23-md.png 768w ,https://rosmianto.com/media/posts/21/responsive/Screenshot-2024-04-06-at-20.49.23-lg.png 1200w ,https://rosmianto.com/media/posts/21/responsive/Screenshot-2024-04-06-at-20.49.23-xl.png 1600w"></figure>
<p>The enclosure is just, beautiful. It runs Linux so pretty easy to develop software on top of it.</p>
<p>Just checkout <a href="https://www.clockworkpi.com/gameshell" target="_blank" rel="noopener noreferrer">their website</a>. Also if you want to immediately see their software and hardware schematics, <a href="https://github.com/clockworkpi/GameShell" target="_blank" rel="noopener noreferrer">just click here</a> you nerdy!</p>
<h1>Gamebuino</h1>
<p>This is my first crush on a open hardware. I found this project from their kickstarter campaign years ago. Before further ado, let me show you this beauty:</p>
<figure ><figure class="post__image post__image--center"><img loading="lazy"  src="https://rosmianto.com/media/posts/21/Screenshot-2024-04-06-at-20.57.44.png" alt="" width="1000" height="459" sizes="(min-width: 37.5em) 1600px, 80vw" srcset="https://rosmianto.com/media/posts/21/responsive/Screenshot-2024-04-06-at-20.57.44-xs.png 384w ,https://rosmianto.com/media/posts/21/responsive/Screenshot-2024-04-06-at-20.57.44-sm.png 600w ,https://rosmianto.com/media/posts/21/responsive/Screenshot-2024-04-06-at-20.57.44-md.png 768w ,https://rosmianto.com/media/posts/21/responsive/Screenshot-2024-04-06-at-20.57.44-lg.png 1200w ,https://rosmianto.com/media/posts/21/responsive/Screenshot-2024-04-06-at-20.57.44-xl.png 1600w"></figure>
<figcaption >If you think this is ugly, we have different standard of beauty!</figcaption>
</figure>
<p>They don't open-sourced the hardware though, but <a href="https://github.com/Gamebuino/Gamebuino-META" target="_blank" rel="noopener noreferrer">their game API to make your own game</a> is valuable. They use ATSAMD21 as the microcontroller. The sickest feature is this console is able to rewriting the flash memory so we can load another new game.</p>
<p>I even ported <a href="https://github.com/rosmianto/gamebuino-esp32" target="_blank" rel="noopener noreferrer">Gamebuino software to work with ESP32</a>:</p>
<figure class="post__image post__image--center"><img loading="lazy"  src="https://rosmianto.com/media/posts/21/gamebuino-esp32.jpg" alt="" width="500" height="375" sizes="(min-width: 37.5em) 1600px, 80vw" srcset="https://rosmianto.com/media/posts/21/responsive/gamebuino-esp32-xs.jpg 384w ,https://rosmianto.com/media/posts/21/responsive/gamebuino-esp32-sm.jpg 600w ,https://rosmianto.com/media/posts/21/responsive/gamebuino-esp32-md.jpg 768w ,https://rosmianto.com/media/posts/21/responsive/gamebuino-esp32-lg.jpg 1200w ,https://rosmianto.com/media/posts/21/responsive/gamebuino-esp32-xl.jpg 1600w"></figure>
<h1>Odroid GO</h1>
<p>Another game console but using ESP32. What special about this device is you can emulate Gameboy, NES, Sega Master game using ESP32. If you want to learn about emulation and low-level optimization, check their <a href="https://github.com/hardkernel/ODROID-GO" target="_blank" rel="noopener noreferrer">GitHub repo</a>.</p>
<p>They open-sourced the hardware schematics and firmware.</p>
<figure class="post__image post__image--center"><img loading="lazy"  src="https://rosmianto.com/media/posts/21/68747470733a2f2f7777772e686172646b65726e656c2e636f6d2f6d61696e2f5f46696c65732f707264742f323031382f3230313830362f3230313830363132303633323139383431372e6a7067.jpg" alt="" width="482" height="468" sizes="(min-width: 37.5em) 1600px, 80vw" srcset="https://rosmianto.com/media/posts/21/responsive/68747470733a2f2f7777772e686172646b65726e656c2e636f6d2f6d61696e2f5f46696c65732f707264742f323031382f3230313830362f3230313830363132303633323139383431372e6a7067-xs.jpg 384w ,https://rosmianto.com/media/posts/21/responsive/68747470733a2f2f7777772e686172646b65726e656c2e636f6d2f6d61696e2f5f46696c65732f707264742f323031382f3230313830362f3230313830363132303633323139383431372e6a7067-sm.jpg 600w ,https://rosmianto.com/media/posts/21/responsive/68747470733a2f2f7777772e686172646b65726e656c2e636f6d2f6d61696e2f5f46696c65732f707264742f323031382f3230313830362f3230313830363132303633323139383431372e6a7067-md.jpg 768w ,https://rosmianto.com/media/posts/21/responsive/68747470733a2f2f7777772e686172646b65726e656c2e636f6d2f6d61696e2f5f46696c65732f707264742f323031382f3230313830362f3230313830363132303633323139383431372e6a7067-lg.jpg 1200w ,https://rosmianto.com/media/posts/21/responsive/68747470733a2f2f7777772e686172646b65726e656c2e636f6d2f6d61696e2f5f46696c65732f707264742f323031382f3230313830362f3230313830363132303633323139383431372e6a7067-xl.jpg 1600w"></figure>
<h1>ScopeFun</h1>
<p>Now something unrelated to game, an oscilloscope. Here you can learn about analog and digital signal processing at high-speed (500 MSps, mega-samples per second).</p>
<figure class="post__image post__image--center"><img loading="lazy"  src="https://rosmianto.com/media/posts/21/Screenshot-2024-04-06-at-21.16.07.png" alt="" width="557" height="322" sizes="(min-width: 37.5em) 1600px, 80vw" srcset="https://rosmianto.com/media/posts/21/responsive/Screenshot-2024-04-06-at-21.16.07-xs.png 384w ,https://rosmianto.com/media/posts/21/responsive/Screenshot-2024-04-06-at-21.16.07-sm.png 600w ,https://rosmianto.com/media/posts/21/responsive/Screenshot-2024-04-06-at-21.16.07-md.png 768w ,https://rosmianto.com/media/posts/21/responsive/Screenshot-2024-04-06-at-21.16.07-lg.png 1200w ,https://rosmianto.com/media/posts/21/responsive/Screenshot-2024-04-06-at-21.16.07-xl.png 1600w"></figure>You <a href="https://www.crowdsupply.com/scopefun/open-source-instrumentation" target="_blank" rel="noopener noreferrer">can buy it</a> or you can just learn it. <a href="https://gitlab.com/scopefun" target="_blank" rel="noopener noreferrer">Their GitLab repo</a> is well-organized. Very recommended to learn high-speed embedded project.</p>
<h1>Open-Smartwatch</h1>
<p>Lastly, an open-source smartwatch. Again, this project is built using ESP32 as the microcontroller. Apparently ESP32 is used in many serious projects (like <a href="https://www.mi.com/pk/mi-air-purifier-3c/" target="_blank" rel="noopener noreferrer">Xiaomi Air Purifier</a>, I know because I've done teardown of this hehe), not limited to hobbyist projects.</p>
<figure class="post__image post__image--center"><img loading="lazy"  src="https://rosmianto.com/media/posts/21/Open-Smartwatch.jpg" alt="" width="1000" height="400" sizes="(min-width: 37.5em) 1600px, 80vw" srcset="https://rosmianto.com/media/posts/21/responsive/Open-Smartwatch-xs.jpg 384w ,https://rosmianto.com/media/posts/21/responsive/Open-Smartwatch-sm.jpg 600w ,https://rosmianto.com/media/posts/21/responsive/Open-Smartwatch-md.jpg 768w ,https://rosmianto.com/media/posts/21/responsive/Open-Smartwatch-lg.jpg 1200w ,https://rosmianto.com/media/posts/21/responsive/Open-Smartwatch-xl.jpg 1600w"></figure>
<p>You can view the operating system, 3D files, hardware design on <a href="https://github.com/Open-Smartwatch" target="_blank" rel="noopener noreferrer">their GitHub repo</a>.</p>
<p>That's all folks. Happy tinkering!</p>
<p>¬†</p>
            ]]>
        </content>
    </entry>
    <entry>
        <title>2 Tips for Improving Your Firmware</title>
        <author>
            <name>Rosmianto A. Saputro</name>
        </author>
        <link href="https://rosmianto.com/2-tips-for-improving-your-firmware.html"/>
        <id>https://rosmianto.com/2-tips-for-improving-your-firmware.html</id>
        <media:content url="https://rosmianto.com/media/posts/19/c-m-iVfOFaEghqU-unsplash.jpg" medium="image" />
            <category term="Embedded Tips"/>

        <updated>2024-03-25T16:10:49+07:00</updated>
            <summary>
                <![CDATA[
                        <img src="https://rosmianto.com/media/posts/19/c-m-iVfOFaEghqU-unsplash.jpg" alt="" />
                    Josh is having a very bad day at work. He is a firmware engineer btw. ‚ÄúWtf? Boss wants 2 more&hellip;
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                    <p><img src="https://rosmianto.com/media/posts/19/c-m-iVfOFaEghqU-unsplash.jpg" class="type:primaryImage" alt="" /></p>
                <div>
<p>Josh is having a very bad day at work. He is a firmware engineer btw.<br><br>‚ÄúWtf? Boss wants 2 more features added to the firmware. Heck, I didn‚Äôt even fix my bug yesterday‚Äù He complained.<br><br>‚ÄúWhy? Aren‚Äôt those 2 features simple to implement?‚Äù I asked him.<br><br>‚ÄúEasier said than done! I need to touch maybe 20 files to do that. I‚Äôm afraid the code will break. It‚Äôs stressing me out!‚Äù He freaked out.<br><br>Here we can see the problem, well 3 problems:<br><br>‚Ä¢ Josh is struggling to add more features<br>‚Ä¢ Josh needs to touch tens of files to make small modifications<br>‚Ä¢ Josh is scared and not confident his work will be stable enough<br><br>Poor Josh. This thing shouldn‚Äôt be happening. Adding features shouldn‚Äôt be scary. In this article, I‚Äôm going to share 2 tips to kill Josh‚Äôs problems. But before we go through those tips, a few important notes:</p>
</div>
<div>
<ul>
<li>
<p>Improving your firmware means you need to improve your thinking. Because writing firmware is basically thinking in code</p>
</li>
<li>
<p>If you have too much hassle developing firmware, it means you need to either automate something or try another approach. Adding features should be straightforward (although not always easy, mind you)</p>
</li>
</ul>
</div>
<div>
<h2>Code Bloat ‚Üí Kill with Method Extraction</h2>
</div>
<div>
<p>Now, when Josh needed to add/change something, he had to modify his code in many locations. The code is similar (or even exactly the same), and he needed to use Ctrl+F to find everything.</p>
</div>
<div>
<p>This issue is called code duplication or code bloats. The solution is by extracting that similar code and create a function with appropriate parameters. For example, Josh has 2 similar code everywhere:</p>
</div>
<div>
<pre><code>// First code block
uint8_t payload[255] = ....;

uint8_t checksum = 0;
for (int i = 0; i &lt; 255; i++) {
    // Long code here..
    checksum = ....;
}</code></pre>
</div>
<div>
<pre><code>// Second code block
uint8_t payload[255] = ....;

uint8_t checksum = 0;
for (int i = 0; i &lt; 254; i++) {
    // Long code here..
    checksum = ....;
}</code></pre>
</div>
<div>
<p>Did you notice the difference between 1st vs 2nd code block?</p>
</div>
<div>
<p>Second block has 254, first block instead has 255. When I asked Josh, he said that the second block for some reason needs to exclude the last byte to calculate the checksum (Wtf Josh, that is dangerous!)</p>
</div>
<div>
<p>Now, those two blocks can be extracted and written into a single function:</p>
</div>
<div>
<pre><code>uint8_t calculateChecksum(uint8_t* payload, bool excludeLastByte) {
    
    uint8_t checksum = 0;
    uint8_t payloadSize = excludeLastByte ? 254 : 255;
    // Long code here...
}</code></pre>
</div>
<div>
<p>From there, we can calculate checksum simply by calling <code>calculateChecksum(payload, true)</code>.</p>
</div>
<div>
<h2>Insecure of Code Stability ‚Üí Kill with Unit Test</h2>
</div>
<div>
<p>We have reduced code bloats into a single function. And this gives us one more benefit: we can test it individually. By using unit test, we can ensure that the code is consistent and outputs the correct value as we expect.</p>
</div>
<div>
<p>Unit testing is basically calling <code>calculateChecksum()</code> with known payload, we compare the actual checksum with the expected value. If they match, we‚Äôre fine.</p>
</div>
<div>
<p>Remember that unit testing doesn‚Äôt necessarily use any testing framework like Catch2, Google Test. As long as you can verify the output, you‚Äôre doing unit tests (However, manual testing is painful as the code grows, that‚Äôs why we use testing framework, to do <strong><i>automated</i></strong><strong>¬†</strong>unit testing)</p>
</div>
<div>
<h2>Summary</h2>
</div>
<div>
<p>Use those 2 tips, and you will be better at dealing with code redundancy and feel confident in your firmware. If you want to explore more about this concept, we have plenty: Test-Driven Development (TDD), Modular programming, Assertion, etc.</p>
</div>
<div>
<p>Those topics are actually interconnected, so take your time to learn them all.</p>
</div>
            ]]>
        </content>
    </entry>
    <entry>
        <title>3 Essential Skills To Survive Embedded Career</title>
        <author>
            <name>Rosmianto A. Saputro</name>
        </author>
        <link href="https://rosmianto.com/3-essential-skills-to-survive-embedded-career.html"/>
        <id>https://rosmianto.com/3-essential-skills-to-survive-embedded-career.html</id>
        <media:content url="https://rosmianto.com/media/posts/18/venn.png" medium="image" />
            <category term="Embedded Career"/>

        <updated>2024-03-25T09:45:24+07:00</updated>
            <summary>
                <![CDATA[
                        <img src="https://rosmianto.com/media/posts/18/venn.png" alt="" />
                    Bob is an embedded software engineer, he thinks that writing well-crafted software is all he needs, so he learns and&hellip;
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                    <p><img src="https://rosmianto.com/media/posts/18/venn.png" class="type:primaryImage" alt="" /></p>
                <div>
<p>Bob is an embedded software engineer, he thinks that writing well-crafted software is all he needs, so he learns and practices:</p>
</div>
<div>
<ul>
<li>
<p>Clean and beautiful software architecture</p>
</li>
<li>
<p>Best design patterns and each use case</p>
</li>
<li>
<p>Algorithms for many problems</p>
</li>
</ul>
</div>
<div>
<p>While his software is beautiful and readable, he is also:</p>
</div>
<div>
<ul>
<li>
<p>Struggling to bring up a new development board his boss asked 2 weeks ago</p>
</li>
<li>
<p>Confused why the device he is working on cannot last long, even with a 10000mAh battery</p>
</li>
<li>
<p>Angry when the sensor is outputting messy data that breaks his algorithm</p>
</li>
</ul>
</div>
<div>
<p>Bob is a good and disciplined engineer, but his boss needs to hire Arjun, another embedded engineer to back him up.</p>
</div>
<div>
<p>Arjun believes that embedded software ‚â† computer software. Because embedded systems are a combination of hardware and software, he thinks that you need to understand electronics and software engineering to make things happen, fast (he‚Äôs right, you know).</p>
</div>
<div>
<p>But because he has weak software skills, the firmware he wrote is hard to maintain and unreadable. Arjun needs to consult a lot to Bob about modular firmware design, and coding best practices.</p>
</div>
<div>
<div>
<blockquote>
<p><i>Yeah, I solved the dev board and the battery issue. The messy output from sensor is because of unstable Vref and incorrect instrumentation op-amp choice. Bob sucks, I love working with him though.</i></p>
<p><span style="font-size: 0.790123em; font-family: var(--font-serif); color: var(--text-primary-color); font-weight: var(--font-weight-normal);">Arjun</span></p>
</blockquote>
</div>
</div>
<div>
<div>
<blockquote>
<p><i>Arjun‚Äôs code is a mess. We‚Äôre best friends now.</i></p>
<p><span style="font-size: 0.790123em; font-family: var(--font-serif); color: var(--text-primary-color); font-weight: var(--font-weight-normal);">Bob</span></p>
</blockquote>
</div>
</div>
<div>
<p>Now, while the story (and the quotes above) is 100% fabricated, I have seen and heard many similar stories: engineers struggle to move forward because of lack of basic understanding of electronics and software design.</p>
</div>
<div>
<p>To successfully work on Embedded Systems, you actually need 3 main skills:</p>
<p>üëâ Computer Science<br>üëâ Electrical Engineering<br>üëâ A third field depending on your interest</p>
</div>
<div>
<p>Take a look at this interesting diagram:</p>
<p>¬†</p>
</div>
<div><figure class="post__image post__image--center"><img loading="lazy"  src="https://rosmianto.com/media/posts/18/venn.avif" alt="" width="434" height="410"></figure></div>
<div>
<p>We need CS because there are programming aspects in Embedded Systems. We have to create robust, and efficient code for the device. Bob is the best example of this.<br><br>We need EE because we will be interfacing with electronic devices like sensors and actuators (thanks Arjun for solving the op-amp problem!).<br><br>Understanding the electronics under the hoods will make your life as an embedded engineer easy.<br><br>Lastly, we need a third field. It means that if we work on embedded devices on vehicles then we need to learn and understand automotive: its standards, the rules, the principles in auto.<br><br>The same with other fields.<br><br>I used to work in mining and marine, so I need to learn and understand how mining processes are done, how harsh the environment is, etc.</p>
</div>
<div>
<p>If we become just either Bob or Arjun, we are crippled.</p>
</div>
<div>
<p>If we become both Bob and Arjun, we are unstoppable.</p>
</div>
            ]]>
        </content>
    </entry>
    <entry>
        <title>Embedded Freelancers, Attract Not Hunt Clients</title>
        <author>
            <name>Rosmianto A. Saputro</name>
        </author>
        <link href="https://rosmianto.com/embedded-freelancer-attract-not-hunt-clients.html"/>
        <id>https://rosmianto.com/embedded-freelancer-attract-not-hunt-clients.html</id>
        <media:content url="https://rosmianto.com/media/posts/17/sebastian-herrmann-NbtIDoFKGO8-unsplash.jpg" medium="image" />
            <category term="Embedded Freelancing"/>

        <updated>2024-03-25T06:16:29+07:00</updated>
            <summary>
                <![CDATA[
                        <img src="https://rosmianto.com/media/posts/17/sebastian-herrmann-NbtIDoFKGO8-unsplash.jpg" alt="" />
                    I've been doing freelance as an embedded since 2021. and I realize one of the important things: There are simply&hellip;
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                    <p><img src="https://rosmianto.com/media/posts/17/sebastian-herrmann-NbtIDoFKGO8-unsplash.jpg" class="type:primaryImage" alt="" /></p>
                <p>I've been doing freelance as an embedded since 2021.</p>
<p>and I realize one of the important things:</p>
<p>There are simply too many project owners struggling to get freelancers. Yes, you read it right. We need more qualified embedded freelancers.</p>
<p>Many project owners send me DM offering projects, but I have to politely decline because of these 2:</p>
<ul>
<li>Their projects industry isn't aligned with my interests</li>
<li>I can't refer them to anybody because my freelance circle's interests are too similar to mine</li>
</ul>
<p>Okay, let's dig deeper into each point.</p>
<h3>Their projects industry isn't aligned with my interests</h3>
<p>My primary interests in embedded systems are low-power devices, wearables, portable devices, and things similar to those.</p>
<p>But sometimes I get this type of DM on LinkedIn:</p>
<figure class="post__image post__image--center"><img loading="lazy"  src="https://rosmianto.com/media/posts/17/Screenshot-2024-03-25-at-05.40.47.png" alt="" width="500" height="152" sizes="(min-width: 37.5em) 1600px, 80vw" srcset="https://rosmianto.com/media/posts/17/responsive/Screenshot-2024-03-25-at-05.40.47-xs.png 384w ,https://rosmianto.com/media/posts/17/responsive/Screenshot-2024-03-25-at-05.40.47-sm.png 600w ,https://rosmianto.com/media/posts/17/responsive/Screenshot-2024-03-25-at-05.40.47-md.png 768w ,https://rosmianto.com/media/posts/17/responsive/Screenshot-2024-03-25-at-05.40.47-lg.png 1200w ,https://rosmianto.com/media/posts/17/responsive/Screenshot-2024-03-25-at-05.40.47-xl.png 1600w"></figure>I have zero clue about what DC001 is.</p>
<p>Apparently it is a protocol for high voltage charging (like 48v to 72v high).</p>
<p>Another potential client asked me to work on his automotive project, my task will be ensuring the system compliance with regulations and standards.</p>
<p>"I'm sorry man, but I know nothing about regulations," I said to him.</p>
<p>"Ah, no worries mate. Know anyone who qualified?" He asked me.</p>
<p>"Uhhm, I'm afraid I don't know anyone suitable. Really sorry"</p>
<p>"Oh very unfortunate, thanks mate!"</p>
<p>Okay, you might ask. Why would a client with an automotive project approach me?</p>
<p>Well, the answer is very obvious. He doesn't know anybody else! Notice his question above.</p>
<h3>I Can't Refer Them</h3>
<p>"You're hanging out with folks similar to yours". Yes, I couldn't agree more.</p>
<p>My circle of friends is pretty similar to mine: low-power, portable products, consumer electronics.</p>
<p>You know, the older you get, the smaller your circle will be. That also happens to my freelance friends. That's why I am active on LinkedIn, to expand my online friends.</p>
<p>Many followers asked me to refer projects to them, yes I've done that honestly.</p>
<p>But, how many of them are working with high-voltage embedded projects? Or know a lot about regulations and standards?</p>
<p>Even if they happen to know, how can I ensure they really know? They don't demonstrate their regulations and standards knowledge on LinkedIn.</p>
<p>Do you really expect me to refer my client to a random person I found on LinkedIn?</p>
<p>My reputation would be at stake.</p>
<p>"Well Rosmianto, you could ask them for their portfolio to assess their skills?"</p>
<p>Why wouldn't they just post it on their LinkedIn üòÇ</p>
<p>I'm not a recruiter. Vetting each person isn't an easy feat.</p>
<h1>Attract, Not Hunt Your Clients</h1>
<p>We need more qualified freelancers who actively demonstrate their knowledge.</p>
<p>You might be an expert, but if nobody knows, how could you land a client?</p>
<p>If you want to become an embedded freelancer, you want to plan long-term.</p>
<p>And reverse your question, from "<em>How to get freelance clients?</em>"</p>
<p>to "<em>How freelance clients easily find me?</em>"</p>
<p>Flipping that question will also flip your entire approach to acquiring clients.</p>
<p>You no longer "ask for project", you will start "inviting them to see your profile".</p>
<p>One of the easiest ways to start attracting clients?</p>
<p>Start showing off your skills on LinkedIn for 30 days straight.</p>
            ]]>
        </content>
    </entry>
</feed>
