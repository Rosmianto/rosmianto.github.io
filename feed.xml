<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xmlns:media="http://search.yahoo.com/mrss/">
    <title>Captain Embedded üë®üèª‚Äç‚úàÔ∏è‚öì</title>
    <link href="https://rosmianto.com/feed.xml" rel="self" />
    <link href="https://rosmianto.com" />
    <updated>2024-08-25T13:52:54+07:00</updated>
    <author>
        <name>Rosmianto A. Saputro</name>
    </author>
    <id>https://rosmianto.com</id>

    <entry>
        <title>The Snake-Game Test üêç</title>
        <author>
            <name>Rosmianto A. Saputro</name>
        </author>
        <link href="https://rosmianto.com/the-snake-game-test.html"/>
        <id>https://rosmianto.com/the-snake-game-test.html</id>
        <media:content url="https://rosmianto.com/media/posts/26/albert-XRhu6Ux1iNA-unsplash.jpg" medium="image" />
            <category term="Embedded Tips"/>

        <updated>2024-08-25T13:52:54+07:00</updated>
            <summary>
                <![CDATA[
                        <img src="https://rosmianto.com/media/posts/26/albert-XRhu6Ux1iNA-unsplash.jpg" alt="" />
                    This is my favorite way to learn embedded systems: The Snake-Game Test. When we‚Äôre learning any topic in embedded systems,&hellip;
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                    <p><img src="https://rosmianto.com/media/posts/26/albert-XRhu6Ux1iNA-unsplash.jpg" class="type:primaryImage" alt="" /></p>
                <p>This is my favorite way to learn embedded systems:</p>
<p>The Snake-Game Test.</p>
<p>When we‚Äôre learning any topic in embedded systems, what really important is the relevance between what we know vs. what we can do.</p>
<p>That‚Äôs why hands-on experiment is extremely important in embedded systems.</p>
<p>The Snake-Game Test is a simple test to check if we do enough hands-on when learning embedded system. It‚Äôs an interesting framework to help you ensure you don‚Äôt waste time learning unnecessary things.</p>
<p>The Snake-Game Test was inspired by me when I was trying to build a snake game using C++.</p>
<p>When I was building the game, I didn't learn the entire C++ language constructs, but I only learned what I needed to build the snake game.</p>
<p>That approach gave me a better understanding of basic game design, and basic C++ constructs. I always know if I want to learn more advanced C++ features, then I can learn it by building even more complex programs.</p>
<p>Here are the 4 foundational concepts of The Snake-Game Test:</p>
<ol>
<li>Real-World Project</li>
<li>Just-In-Time learning</li>
<li>Extremely Hands-On</li>
<li>Iteratively Improve the Project</li>
</ol>
<p>Let's dive right into each concept.</p>
<h1>Real-World Project</h1>
<p>If what you do is hypothetical projects like foobar, building linked list, etc. You'll struggle to apply the topic you're learning.</p>
<p>Instead, pick a real-world project, that's concrete enough for you to work on, like the Snake game. Everyone has played snake game at some point in their life.</p>
<p>Instead of writing program with 1000 linked-list, why not create a snake-game¬†<em><strong>that applies linked-list concept to the snake?</strong></em></p>
<h1>Just-In-Time Learning</h1>
<p>Instead of learning everything upfront (which takes too much time), The Snake-Game Framework encourages you to learn just enough to make the project work.</p>
<p>Instead of learning every C++ feature from a book, learn just enough to make the snake move. Start by asking questions:</p>
<ul>
<li>Snake usually moves in grid, how to implement grid system in C++?</li>
<li>How do I actually¬†<em>draw</em> image using C++?</li>
<li>How to make the snake move? What data structure to use?</li>
<li>How to place snake's food at random places?</li>
<li>How to detect the snake biting itself?</li>
<li>Etc.</li>
</ul>
<p>By answering the questions above, you are guaranteed to learn and use only the important things of C++ for the snake game.</p>
<p>Another example, let's say you want to learn MQTT and decide to build a temperature monitoring system. You don't read the source code of HiveMQ Broker. Instead, you ask these questions:</p>
<ul>
<li>What is MQTT? How can I send data from A to B?</li>
<li>What is MQTT Topic? What is QoS? What's the difference?</li>
<li>Should I write my own client or is there ready-to-use library for MQTT?</li>
<li>etc.</li>
</ul>
<p>That way, you won't overwhelm yourself with the complexity of MQTT broker source code. You will have good experience and great understanding of the basics.</p>
<h1>Extremely Hands-On</h1>
<p>We're not doing theoretical study here.</p>
<p>We're not analyzing the game design mechanics, reward system, level-up mechanism, etc. We want to build the damn snake-eating-food game until it dies.</p>
<p>We're not writing an essay on how MQTT actually sends and transmits data.</p>
<p>We're not writing an essay comparing MQTT vs. HTTP vs. WebSocket.</p>
<p>We're building something. Period.</p>
<p>Yes, you might have to research a bit, but the goal is to assist you in building the project, not writing essay.</p>
<h1>Iterative Approach</h1>
<p>The Snake-Game Framework encourages iterative process.</p>
<p>First, you make the program draw grid. No snake yet? No problem.</p>
<p>Second, you make the program render the snake. No foods yet? No problem.</p>
<p>Third, you make the snake move and add food. Buggy? Good. Fix it.</p>
<p>Next, you start adding wall detection, self-bite detection, etc.</p>
<p>The point is, nobody is watching you, so you might want to make as many stupid mistakes as humanly possible (you will be surprised how many recompilations I did just to fix a simple bug).</p>
<p>This Snake-Game Test (probably I should call it "framework") will <strong>help you close the gap between what you know vs. what you can do</strong>.</p>
<p>Happy learning! üêç</p>
<p><!-- notionvc: 341f702b-7600-4fac-8e06-459ae9cecf46 --></p>
            ]]>
        </content>
    </entry>
    <entry>
        <title>6 Strategies for Learning ESP-IDF (without going insane)</title>
        <author>
            <name>Rosmianto A. Saputro</name>
        </author>
        <link href="https://rosmianto.com/strategies-for-learning-esp-idf-and-not-going-insane.html"/>
        <id>https://rosmianto.com/strategies-for-learning-esp-idf-and-not-going-insane.html</id>
        <media:content url="https://rosmianto.com/media/posts/24/kevin-ku-w7ZyuGYNpRQ-unsplash.jpg" medium="image" />
            <category term="Embedded Tips"/>

        <updated>2024-06-24T12:06:33+07:00</updated>
            <summary>
                <![CDATA[
                        <img src="https://rosmianto.com/media/posts/24/kevin-ku-w7ZyuGYNpRQ-unsplash.jpg" alt="" />
                    If you try to write firmware for ESP32 microcontroller, you will have two popular choices: Arduino is easier. And you&hellip;
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                    <p><img src="https://rosmianto.com/media/posts/24/kevin-ku-w7ZyuGYNpRQ-unsplash.jpg" class="type:primaryImage" alt="" /></p>
                <p>If you try to write firmware for ESP32 microcontroller, you will have two popular choices:</p>
<ol>
<li>Arduino framework</li>
<li>ESP-IDF</li>
</ol>
<p>Arduino is easier. And you probably have good experience with AVR-based Arduino boards (like UNO, Nano, Mega2560, etc.), so writing firmware for ESP32 using Arduino is seamless.</p>
<p>You already know the basics.</p>
<p>But because Arduino framework is designed to be simple, lots of concepts are hidden from you. When you work with a slightly more complex project, you will quickly realize that Arduino won't cut it.</p>
<p>For example, let's say you want to build a BLE scanner using ESP32.</p>
<p>The goal is simple: to scan nearby BLE devices as fast as possible, if the scanning process is too slow, you will miss some BLE devices. It's often required if you want to track BLE device movements.</p>
<p>Now, you can scan BLE devices using Arduino framework, yes. But it will be noticeably slower. So, there's no other choice: use ESP-IDF for better performance.</p>
<p>However, using ESP-IDF is not without downsides. Just take a look at this code comparison below:</p>
<figure ><figure class="post__image post__image--center"><img loading="lazy"  src="https://rosmianto.com/media/posts/24//Konthen.drawio.png" alt="" width="1000" height="664" sizes="(min-width: 37.5em) 1600px, 80vw" srcset="https://rosmianto.com/media/posts/24//responsive/Konthen.drawio-xs.png 384w ,https://rosmianto.com/media/posts/24//responsive/Konthen.drawio-sm.png 600w ,https://rosmianto.com/media/posts/24//responsive/Konthen.drawio-md.png 768w ,https://rosmianto.com/media/posts/24//responsive/Konthen.drawio-lg.png 1200w ,https://rosmianto.com/media/posts/24//responsive/Konthen.drawio-xl.png 1600w"></figure>
<figcaption >Left: Arduino code. Right: ESP-IDF example code for ADC</figcaption>
</figure>
<p>Both essentially do the same thing: sample analog signal, and printout the value.</p>
<p>But the right side is hard to follow, especially if you're not familiar with ESP-IDF. There are too many things to unpack here:</p>
<ul>
<li>Okay I know ADC. But what's that <em>oneshot</em> thing?</li>
<li>What ESP_ERROR_CHECK will do?</li>
<li>Why ADC needs calibration?</li>
<li>Wait, there are TWO ADCs inside ESP32?</li>
<li>Why there's so many #include?</li>
<li>Why it's called vTaskDelay() and not just delay()?</li>
</ul>
<p>You see, there are many concepts hidden in Arduino framework. No wonder people said they struggle to learn ESP-IDF.</p>
<p>So, I will share with you my 6 strategies (plus 1 bonus strategy) to learn ESP-IDF without going insane.</p>
<h1>Strategy #1: Hone Your C Skill, Especially Function Pointer and Callback</h1>
<p>ESP-IDF is written in C. It's actually a good thing because as a framework, it should ensure interoperability with many other languages. C is the lowest common denominator for embedded programming.</p>
<p>ESP-IDF can be sometimes heavy on OOP concepts, and because it's written in C, the framework uses lots of function pointers and callback and pass-by-reference to mimic C++ OOP.</p>
<p>You can be confused if you don't understand the basics of function pointer and callback in C.</p>
<h1>Strategy #2: Think in Subsystem, not Linear Thinking</h1>
<p>I'm sorry for saying jargon.</p>
<p>Basically by thinking in subsystem, you focus your attention on different parts of the system and how all those parts interact and influence each other.</p>
<p>Linear thinking is when you think step-by-step, like BASIC or Assembly programming. It's procedural thinking.</p>
<p>ESP-IDF can sometimes be heavy on event-driven as well. So System thinking will be extremely helpful for you. Now let me give you an example.</p>
<p>Let's check the ESP-IDF example code for WiFi:</p>
<figure class="post__image post__image--center"><img loading="lazy"  src="https://rosmianto.com/media/posts/24/Screenshot-2024-06-23-at-15.33.43.png" alt="" width="1000" height="465" sizes="(min-width: 37.5em) 1600px, 80vw" srcset="https://rosmianto.com/media/posts/24/responsive/Screenshot-2024-06-23-at-15.33.43-xs.png 384w ,https://rosmianto.com/media/posts/24/responsive/Screenshot-2024-06-23-at-15.33.43-sm.png 600w ,https://rosmianto.com/media/posts/24/responsive/Screenshot-2024-06-23-at-15.33.43-md.png 768w ,https://rosmianto.com/media/posts/24/responsive/Screenshot-2024-06-23-at-15.33.43-lg.png 1200w ,https://rosmianto.com/media/posts/24/responsive/Screenshot-2024-06-23-at-15.33.43-xl.png 1600w"></figure>
<p>it's just a code to initialize the ESP32 WiFi to act as an Access Point.</p>
<p>Notice that ugly <code>esp_event_handler_instance_register</code> function?</p>
<p>It's responsible for adding event handling to the API. Whenever the WiFi state changes (like something connected, or disconnected), the function <code>wifi_event_handler</code> (the callback function) will be called later. And here is the function implementation:</p>
<figure class="post__image post__image--center"><img loading="lazy"  src="https://rosmianto.com/media/posts/24/Screenshot-2024-06-23-at-15.37.35.png" alt="" width="1000" height="352" sizes="(min-width: 37.5em) 1600px, 80vw" srcset="https://rosmianto.com/media/posts/24/responsive/Screenshot-2024-06-23-at-15.37.35-xs.png 384w ,https://rosmianto.com/media/posts/24/responsive/Screenshot-2024-06-23-at-15.37.35-sm.png 600w ,https://rosmianto.com/media/posts/24/responsive/Screenshot-2024-06-23-at-15.37.35-md.png 768w ,https://rosmianto.com/media/posts/24/responsive/Screenshot-2024-06-23-at-15.37.35-lg.png 1200w ,https://rosmianto.com/media/posts/24/responsive/Screenshot-2024-06-23-at-15.37.35-xl.png 1600w"></figure>
<p>Don't worry about those alien macros and structs yet.</p>
<p>Now, the question is. When exactly this function will be executed? Like how many seconds after bootup?</p>
<p>The answer is we don't know. It's the nature of event-driven programming. The function will only be executed only if the WiFi state is changed.</p>
<p>That's why we can't rely on <strong>l</strong><strong>inear thinking</strong>, because we would be confused as hell. With <strong>system</strong> <strong>thinking</strong>, we will understand that the WiFi event will interact with our <code>wifi_event_handler</code> function <em>later</em>.</p>
<p>ESP-IDF has an insanely large amount of event-driven programming, especially if you work with WiFi and Bluetooth.</p>
<p>So, force yourself really hard in system thinking, not procedural/linear thinking.</p>
<h1>Strategy #3: Use VSCode 'Goto Definition' Feature</h1>
<p>ESP-IDF encapsulates many data formats and structures inside <code>struct</code>, and sometimes we want to know the full structure of the datatype. Look at this GPIO example code:</p>
<figure class="post__image post__image--center"><img loading="lazy"  src="https://rosmianto.com/media/posts/24/Screenshot-2024-06-24-at-11.22.20.png" alt="" width="476" height="314" sizes="(min-width: 37.5em) 1600px, 80vw" srcset="https://rosmianto.com/media/posts/24/responsive/Screenshot-2024-06-24-at-11.22.20-xs.png 384w ,https://rosmianto.com/media/posts/24/responsive/Screenshot-2024-06-24-at-11.22.20-sm.png 600w ,https://rosmianto.com/media/posts/24/responsive/Screenshot-2024-06-24-at-11.22.20-md.png 768w ,https://rosmianto.com/media/posts/24/responsive/Screenshot-2024-06-24-at-11.22.20-lg.png 1200w ,https://rosmianto.com/media/posts/24/responsive/Screenshot-2024-06-24-at-11.22.20-xl.png 1600w"></figure>
<p>If I want to know the exact structure of <code>gpio_config_t</code>, I could look it up from the documentation, but that's tedious!</p>
<p>Instead, I just right-click it and select 'Goto Definition'. It's enough for me to understand the data structure. But if I want more explanation, then I'll go to the official docs.</p>
<figure class="post__image post__image--center"><img loading="lazy"  src="https://rosmianto.com/media/posts/24/Screenshot-2024-06-24-at-11.24.22.png" alt="" width="423" height="397" sizes="(min-width: 37.5em) 1600px, 80vw" srcset="https://rosmianto.com/media/posts/24/responsive/Screenshot-2024-06-24-at-11.24.22-xs.png 384w ,https://rosmianto.com/media/posts/24/responsive/Screenshot-2024-06-24-at-11.24.22-sm.png 600w ,https://rosmianto.com/media/posts/24/responsive/Screenshot-2024-06-24-at-11.24.22-md.png 768w ,https://rosmianto.com/media/posts/24/responsive/Screenshot-2024-06-24-at-11.24.22-lg.png 1200w ,https://rosmianto.com/media/posts/24/responsive/Screenshot-2024-06-24-at-11.24.22-xl.png 1600w"></figure>
<p>That way, I'll understand the API context much easier and faster.</p>
<h1>Strategy #4: Go back to the theory!</h1>
<p>I'll admit, the reason why ESP-IDF seems hard to learn is because <em>it's actually more complex</em>. And by more complex, I mean the framework doesn't hide many details in the code (unlike Arduino framework).</p>
<p>Even if we open the example code, it still feels overwhelming.</p>
<p>Remember, ESP-IDF provides¬†<em><strong>example</strong> </em><strong>projects</strong>, not¬†<em><strong>tutorials</strong></em><em>.¬†</em>Mind the difference!</p>
<p>The goal is to provide as many details as possible, covering many use cases. Not being tutorials, ESP-IDF expects you to be familiar with lots of terms before.</p>
<p>For example, just open the example code for BLE. It's complex:</p>
<figure class="post__image post__image--center"><img loading="lazy"  src="https://rosmianto.com/media/posts/24/Screenshot-2024-06-24-at-11.39.17.png" alt="" width="643" height="326" sizes="(min-width: 37.5em) 1600px, 80vw" srcset="https://rosmianto.com/media/posts/24/responsive/Screenshot-2024-06-24-at-11.39.17-xs.png 384w ,https://rosmianto.com/media/posts/24/responsive/Screenshot-2024-06-24-at-11.39.17-sm.png 600w ,https://rosmianto.com/media/posts/24/responsive/Screenshot-2024-06-24-at-11.39.17-md.png 768w ,https://rosmianto.com/media/posts/24/responsive/Screenshot-2024-06-24-at-11.39.17-lg.png 1200w ,https://rosmianto.com/media/posts/24/responsive/Screenshot-2024-06-24-at-11.39.17-xl.png 1600w"></figure>
<p>What you see above is the parameter for <em>BLE payload advertisement</em>.</p>
<p>Confused with BLE advertisement? Why would the BLE device advertise something?</p>
<p>You won't understand the code if you don't understand the theory behind BLE standard. There are tons of terms and jargon, so you need to be familiar with:</p>
<ul>
<li>BLE advertisements</li>
<li>BLE scanning</li>
<li>GATT profile</li>
<li>BLE Services</li>
<li>BLE architecture</li>
<li>BLE software stack (nimble vs. Bluedroid)</li>
<li>etc.</li>
</ul>
<p>If you work with ADC, then you need to understand first:</p>
<ul>
<li>Different types of ADC (SAR, Sigma-Delta, Dual-slope ADC, etc.)</li>
<li>Bit-width</li>
<li>Sampling rate</li>
<li>Sampling mode (continuous vs. oneshot)</li>
<li>ADC resolution and accuracy</li>
<li>Quantization</li>
<li>Reference Voltage</li>
<li>Calibration and compensation (temperature etc.)</li>
</ul>
<p>If you never heard most of the concepts above, no wonder you will struggle to understand ESP-IDF because it assumes you're already familiar with them.</p>
<p>So, go back to your textbooks and reference manuals from major semiconductor vendors.</p>
<h1>Strategy #5: Don't Create Project from Scratch, Copy from Example Code Instead</h1>
<p>Building firmware is hard enough, so don't torture yourself by creating projects from scratch.</p>
<p>Use example code. Pick one that's closest to your needs. For example, if you want to create firmware to interface I2C EEPROM, don't write from zero. ESP-IDF already provides that.</p>
<p>Use it.</p>
<p>ESP-IDF license should be good for you to copy their code (It's not legal advice though).</p>
<h1>Strategy #6: Read ESP-IDF docs over and over again</h1>
<p>This is the most obvious tip.</p>
<p>You need to read the documentation over and over again.</p>
<p>Because first read you won't understand a thing.</p>
<p>But second read you will pick up some more details.</p>
<p>The third read you will understand the context and the nuance.</p>
<p>The fourth read you're already familiar where to look for extra details.</p>
<p>The fifth read you will become more and more comfortable with the ESP-IDF inside out.</p>
<p><em><strong>But that requires time!</strong></em></p>
<p>Duh? In which world learning doesn't require time?</p>
<h1>Bonus Strategy: Learn FreeRTOS concepts</h1>
<p>This is probably an underrated strategy.</p>
<p>You should understand that ESP-IDF uses FreeRTOS APIs almost all the time.</p>
<p>So, you need to also familiar with FreeRTOS concepts to understand ESP-IDF code.</p>
<ul>
<li>Task management (creation, delete, suspend, resume)</li>
<li>Queue</li>
<li>Semaphore</li>
<li>Mutex</li>
<li>Event Group</li>
<li>Notification</li>
<li>etc.</li>
</ul>
<p>Good luck with learning ESP-IDF!</p>
<p>¬†</p>
            ]]>
        </content>
    </entry>
    <entry>
        <title>Transitioning from Arduino to STM32? There Are Some Caveats You Should Know</title>
        <author>
            <name>Rosmianto A. Saputro</name>
        </author>
        <link href="https://rosmianto.com/transitioning-from-arduino-to-stm32-there-are-some-caveats-you-should-know.html"/>
        <id>https://rosmianto.com/transitioning-from-arduino-to-stm32-there-are-some-caveats-you-should-know.html</id>
        <media:content url="https://rosmianto.com/media/posts/23/8olf2u-2.jpg" medium="image" />
            <category term="Embedded Productivity"/>

        <updated>2024-05-02T12:11:14+07:00</updated>
            <summary>
                <![CDATA[
                        <img src="https://rosmianto.com/media/posts/23/8olf2u-2.jpg" alt="" />
                    You've learned Arduino and feel confident with your basic embedded skills. Now you want to upgrade yourself by learning STM32.
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                    <p><img src="https://rosmianto.com/media/posts/23/8olf2u-2.jpg" class="type:primaryImage" alt="" /></p>
                <p>You've learned Arduino and feel confident with your basic embedded skills. Now you want to upgrade yourself by learning STM32. It should be the next logical step, right?</p>
<p>First of all, I want to say congratulations to you because you've proved yourself that you enjoy embedded systems. Not many people can go through that phase.</p>
<p>Now, this is the new phase. Learning something more "serious" like STM32. (though you can seriously use Arduino as well, <a href="https://rosmianto.com/yes-you-can-use-arduino-for-commercial-grade-only-if-you-do-this.html" target="_blank" rel="noopener noreferrer">with some tips</a>).</p>
<p>I promise you, learning STM32 will be a delightful experience, and you won't regret a single bit (pardon the pun). But to ensure the smoothest transition, I will offer you some of my wisdom.</p>
<figure class="post__image post__image--center" ><img loading="lazy" src="https://rosmianto.com/media/posts/23//8olf2u.jpg" alt="" width="521" height="323" sizes="(min-width: 37.5em) 1600px, 80vw" srcset="https://rosmianto.com/media/posts/23//responsive/8olf2u-xs.jpg 384w ,https://rosmianto.com/media/posts/23//responsive/8olf2u-sm.jpg 600w ,https://rosmianto.com/media/posts/23//responsive/8olf2u-md.jpg 768w ,https://rosmianto.com/media/posts/23//responsive/8olf2u-lg.jpg 1200w ,https://rosmianto.com/media/posts/23//responsive/8olf2u-xl.jpg 1600w">
<figcaption >If you watched Avatar Aang, please read my tips using Roku's voice.</figcaption>
</figure>
<p>There are several things you need to know to ensure a smooth transition (not as smooth as butter though, you still have to learn a lot):</p>
<div class="post__toc">
<h3>¬†</h3>
<ul>
<li><a href="#mcetoc_1hsp0ir5s46">Which STM32 board should you choose?</a></li>
<li><a href="#mcetoc_1hsp0ir5s47">To maximize learning, don't use Arduino framework</a></li>
<li><a href="#mcetoc_1hsp0ir5s48">CMSIS, HAL, mbed, Keil, IAR, CubeMX. What the hell are they?</a></li>
<li><a href="#mcetoc_1hsp0ir5s49">Different way to configure peripherals</a></li>
<li><a href="#mcetoc_1hsp0ir5s4a">Different build system (and flags)</a></li>
<li><a href="#mcetoc_1hsp0ir5s4b">Different library structure</a></li>
<li><a href="#mcetoc_1hsp0ir5s4c">More debugging feature</a></li>
</ul>
</div>
<p>¬†</p>
<p>Let's dive into each point.</p>
<h1 id="mcetoc_1hsp0ir5s46">Which STM32 board should you choose?</h1>
<p>If you just want to pick one board. Choose the blue pill. That's it. It's good enough for you to get started. Blue pill means the STM32 board's form-factor is like a giant pill and the color is blue.</p>
<p>Usually blue pills contain <strong>STM32F103</strong> microcontroller which is pretty good for various basic projects.</p>
<figure class="post__image post__image--center" ><img loading="lazy" src="https://rosmianto.com/media/posts/23/STM32F103C8T6_Blue_Pill-4-2.jpg" alt="" width="539" height="359" sizes="(min-width: 37.5em) 1600px, 80vw" srcset="https://rosmianto.com/media/posts/23/responsive/STM32F103C8T6_Blue_Pill-4-2-xs.jpg 384w ,https://rosmianto.com/media/posts/23/responsive/STM32F103C8T6_Blue_Pill-4-2-sm.jpg 600w ,https://rosmianto.com/media/posts/23/responsive/STM32F103C8T6_Blue_Pill-4-2-md.jpg 768w ,https://rosmianto.com/media/posts/23/responsive/STM32F103C8T6_Blue_Pill-4-2-lg.jpg 1200w ,https://rosmianto.com/media/posts/23/responsive/STM32F103C8T6_Blue_Pill-4-2-xl.jpg 1600w">
<figcaption >The Blue Pill with STM32F103 microcontroller. Image: stm32-base.org</figcaption>
</figure>
<p>Of course you can pick other boards. For example, if you want to focus on low-power project (aka battery-powered), you can explore STM32L series. Personally I'd go with L0 series (e.g. <strong>STM32L072</strong>) if I want to squeeze battery life, but with the cons being slower and not suitable for high-computing projects.</p>
<p>If I need more performance, I'd go with the L4 series (e.g. <strong>STM32L476</strong>). It has Floating-Point Unit (FPU) and larger memory. Great for projects like smartwatch. I have a project where I need to perform 1000 float/double calculations per second on the fly. L0 won't cut it. L4 series will crush this requirement.</p>
<p>You probably won't need more powerful boards right now. But if you do need some inspiration, you could use H5 or H7 series if you're doing crazy stuff like high-speed DSP, or AI/ML stuff.</p>
<p>But again, if you're just starting out the Blue Pill will do just fine.</p>
<h1 id="mcetoc_1hsp0ir5s47">To maximize learning, don't use Arduino framework</h1>
<p>Yes, you read that right. Though I have no issue if you use Arduino framework professionally, I think you should ditch Arduino framework this time.</p>
<blockquote>
<p>Wait, you could use Arduino framework with Blue Pill?</p>
<p>Yes. Search "STM32duino".</p>
</blockquote>
<p>Because you have used Arduino board like UNO or Pro or Micro before, you definitely have used Arduino framework (you know, if you used <code>Serial.begin(115200)</code> before, it's Arduino framework).</p>
<p>STM32 microcontroller is way too powerful compared to basic ATMega328 chip.</p>
<p>Arduino, in your case, will hinder your learning progress and will hide too many interesting features an STM32 microcontroller has to offer.</p>
<h1 id="mcetoc_1hsp0ir5s48">CMSIS, HAL, mbed, Keil, IAR, CubeMX. What the hell are they?</h1>
<p>They are tools and libraries in STM32 ecosystem.</p>
<p>ARM (the company) created ARM Cortex-M (the processor) and wrote libraries for it and call it <strong>CMSIS</strong>.</p>
<p>ST Microelectronics created microcontrollers (like STM32F103) and used Cortex-M as the processor. ST then wrote libraries for STM32F103 and called it <strong>HAL</strong> (on top of the CMSIS).</p>
<p><strong>mbed</strong> is ARM (the company) version of Arduino framework, it's far more powerful than Arduino. You probably want to get experience on HAL first, then if you're interested, you could try mbed.</p>
<p>Now, your firmware source code needs to be compiled so you can get the binary and flash it into the microcontroller. There are many options you can take:</p>
<ul>
<li>GCC Compiler. Free, but not too optimized for STM32 microcontroller.</li>
<li>IAR Compiler. Optimized binary result, but paid or limited feature in free version.</li>
<li>Keil Compiler. Also optimized and limited feature in free version.</li>
</ul>
<p>Pick GCC, it should enough for now. As you gain more experience and knowledge, you probably want to switch to IAR or Keil offering.</p>
<p>ST Microelectronics offers a tool called <strong>STM32CubeMX</strong> to generate a boilerplate (template project for you to get started).</p>
<p>Why would you need a boilerplate? Because STM32 microcontrollers have tons of peripherals, and each of them has tons of configuration. It's tedious and painful to write code manually over and over again, so ST created a tool to assist you generating the basic code.</p>
<h1 id="mcetoc_1hsp0ir5s49">Different way to configure peripherals</h1>
<p>I'd say it again, STM32 microcontrollers have tons of peripherals, and each of them has tons of configuration. Let me give you an example:</p>
<p>In STM32, you will find something called <strong>Clock Tree</strong>.</p>
<p>Unlike your classic ATMega328 which uses a single clock for the entire chip, STM32 can have different clock speeds for each of its peripherals. Why you might ask? In summary it's for flexibility.</p>
<figure class="post__image post__image--center" ><img loading="lazy" src="https://rosmianto.com/media/posts/23/Screenshot-2024-05-02-at-08.32.18.png" alt="" width="651" height="294" sizes="(min-width: 37.5em) 1600px, 80vw" srcset="https://rosmianto.com/media/posts/23/responsive/Screenshot-2024-05-02-at-08.32.18-xs.png 384w ,https://rosmianto.com/media/posts/23/responsive/Screenshot-2024-05-02-at-08.32.18-sm.png 600w ,https://rosmianto.com/media/posts/23/responsive/Screenshot-2024-05-02-at-08.32.18-md.png 768w ,https://rosmianto.com/media/posts/23/responsive/Screenshot-2024-05-02-at-08.32.18-lg.png 1200w ,https://rosmianto.com/media/posts/23/responsive/Screenshot-2024-05-02-at-08.32.18-xl.png 1600w">
<figcaption >The Clock Tree. STM32 even have 2 crystals with different frequencies (left blue boxes).</figcaption>
</figure>
<p>Now, configuring clock tree is error-prone when it's done manually, that's why we use CubeMX to help us generate correct settings for the entire system.</p>
<p>This is drastically different in Arduino, where we simply use <code>Serial.begin()</code> for UART peripheral, <code>SPI.begin()</code> for the SPI, and so on. Because the configuration is simple, we can do it in a single line. No need to have CubeMX for Arduino.</p>
<p>This is something you need to be aware of when exploring STM32. You will need CubeMX almost all the time.</p>
<p>I said this so you won't be surprised with the tooling.</p>
<h1 id="mcetoc_1hsp0ir5s4a">Different build system (and flags)</h1>
<p>In Arduino, usually we just click a button to compile the source code and flash binary to the board. We don't really care about the process. What we expect is to just get the board flashed.</p>
<p>Although we can automate the build process in STM32, we will have to make effort to understand the build system. For example, you need to understand linker script, CMake script, what files to compile, etc.</p>
<p>In Arduino you can't set the compile and linking flags. Heck, we don't even understand what is compiler "flags". Yes, it's an important topic but Arduino hides them from us.</p>
<p>Actually this topic alone is worth a book chapter, and I won't go deeper here. I'm just giving you a caution so you won't discouraged when things are getting harder (because it will be harder).</p>
<h1 id="mcetoc_1hsp0ir5s4b">Different library structure</h1>
<p>This is probably the most difficult thing to accept as someone transitioning from Arduino to STM32.</p>
<p>Arduino libraries have their own structure and way of operating. And they are, in general, not compatible with STM32 ecosystem (except someone has ported the libs).</p>
<p>For example, <a href="https://github.com/adafruit/Adafruit_SSD1306" target="_blank" rel="noopener noreferrer">this OLED display library</a> cannot directly be used for STM32 HAL. You need to port it manually (which requires some skills).</p>
<p>Some libraries are platform-independent, this is the kind of library I love. Some examples are <a href="https://github.com/mikalhart/TinyGPSPlus" target="_blank" rel="noopener noreferrer">TinyGPS</a> (with minor modifications), <a href="https://github.com/bblanchon/ArduinoJson" target="_blank" rel="noopener noreferrer">ArduinoJSON</a>, and <a href="https://github.com/boschsensortec/BMI160_SensorAPI" target="_blank" rel="noopener noreferrer">Bosch BMI160 driver</a> (not beginner-friendly though). So I can use them pretty much without much changes to use for my STM32 HAL projects.</p>
<p>So embrace the fact you will find yourself writing (or porting) driver for anything not Arduino compatible.</p>
<h1 id="mcetoc_1hsp0ir5s4c">More debugging feature</h1>
<p>In STM32 you will get more advanced debugging options: JTAG, SWD, as well as the classic printf().</p>
<p>The cool thing about advanced debugging is you can gain much deeper information about the <strong><em>system state</em></strong>. It's just a fancy word to describe current memory condition. You can see every variable's content, what functions are being called, what caused crash, how much memory a task consumes, etc.</p>
<p>You cannot do that using Arduino.</p>
<p>But for every advanced technology, there is always an additional effort to understand and use it.</p>
<p>So, make the effort and learn them.</p>
<p>There you have it. Happy learning STM32!</p>
<p>¬†</p>
            ]]>
        </content>
    </entry>
    <entry>
        <title>How I Created 100 Embedded Side Projects (With Examples)</title>
        <author>
            <name>Rosmianto A. Saputro</name>
        </author>
        <link href="https://rosmianto.com/how-i-created-100-embedded-side-projects-with-examples.html"/>
        <id>https://rosmianto.com/how-i-created-100-embedded-side-projects-with-examples.html</id>
        <media:content url="https://rosmianto.com/media/posts/22/hunter-haley-s8OO2-t-HmQ-unsplash.jpg" medium="image" />
            <category term="Embedded Productivity"/>

        <updated>2024-04-29T21:35:21+07:00</updated>
            <summary>
                <![CDATA[
                        <img src="https://rosmianto.com/media/posts/22/hunter-haley-s8OO2-t-HmQ-unsplash.jpg" alt="" />
                    The fastest way to 10x your embedded learning progress is by building tons of side projects. I'd say you should&hellip;
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                    <p><img src="https://rosmianto.com/media/posts/22/hunter-haley-s8OO2-t-HmQ-unsplash.jpg" class="type:primaryImage" alt="" /></p>
                <p>The fastest way to 10x your embedded learning progress is by building <a href="https://rosmianto.com/2-rule-method-for-experimental-projects.html" target="_blank" rel="noopener noreferrer">tons of side projects</a>. I'd say you should aim for at least 100 side projects.</p>
<p>Don't worry about quality, just build tons of crappy craps. Because your mission isn't to build world-class firmware, but to learn the basics, the nuance, the context of embedded development.</p>
<p>Now, you might ask "<em>100 is a big number, how the hell I could produce that much? What should I build?"</em></p>
<p>Well, first of all. You are absolutely right. 100 projects is¬†<em>plenty</em>. But you don't actually build them in a week. I built them for years, in my spare time.</p>
<p>And regarding what you should build, here are 3 ways of doing it:</p>
<ol>
<li>Use Google and Pinterest (search "<em>embedded project ideas</em>", and see what you like to build)</li>
<li>Use ChatGPT (prompt "<em>I'm a junior/senior engineer with X years of experience looking for project ideas. My interest is low-power project, list 20 project ideas, be concise</em>")</li>
<li>Or, my personal way of doing it: Project Stacking Method</li>
</ol>
<h1>Use My Way: Project Stacking Method</h1>
<p>Project Stacking Method is just some method I randomly invented. Basically <em>you don't build random projects, but build a new project based on your previous projects</em>.</p>
<p>Confused? Let me explain.</p>
<p>I will start by asking myself this question: <em>what's the embedded-equivalent of "hello world"?</em> The answer is obviously blinking LED.</p>
<h2>Project #1: Blinking an LED</h2>
<p>Okay, that's my first side project, just blinking an LED.</p>
<p>By building this project, I learned how to create a simple sketch using Arduino, how to pick the right current-limiting resistor for the LED, lastly I learned that delay() will determine the blinking frequency of my LED. Good and simple enough.</p>
<p><strong><em>"Oh come on Ross, blinking LED is toooo easy. I need more advanced topics."</em></strong></p>
<p>If you think that's too simple (which is true btw). Let's create another project.</p>
<p>I will ask myself: <em>If I can build an LED to blink, how can I build a "breathing" LED?</em></p>
<h2>Project #2: A Fading LED</h2>
<p>Yes, breathing LED is called fading LED. By building this project, I learned that fading LED can't use simple GPIO toggle which is digital. I need¬†<em>analog signal</em>.</p>
<p>How do I generate analog signal using Arduino? I found out that PWM is the answer.</p>
<p>I just stacked my fading LED project on top my blinking LED. This is interesting because I now can adjust the brightness of my LED.</p>
<p><em><strong>More complexity please!</strong></em>¬†</p>
<p>I will then ask: wait, my LED is just a single color. How can I fade an RGB LED?</p>
<p><strong>Project #3: A fading RGB LED</strong>. Wait, RGB is fascinating. I want moreeee.</p>
<p><strong>Project #4: 3 fading RGB LEDs</strong>. Haha this is fun. I want 8 RGB LEDs.</p>
<p><strong>Project #5: 8 fading RGB LEDs</strong>. Well, this is getting complex. Not enough PWM pins, so I need to use shift-registers to control all 24 signal pins. I learned much about bit serialization, register concepts. I guess I'm ready for more complex project.</p>
<p><strong>Project #6: 8x8 fading RGB LEDs</strong>. Oh my goddd, this is getting out of hand. Now I need to be careful with the timing, and memory management. I need to pump out the serialized bits fast enough to make it good. I had enough LED project.</p>
<p><strong>Project #7: Connecting microcontroller to network via WiFi</strong>. Okay, this is interesting. I will probably use ESP32. You know what, I think I want to control those 8x8 fading RGB LEDs using my smartphone.</p>
<p><strong>Project #8: Controlling 8x8 RGB LEDs via WiFi</strong>. I learned how to use MQTT to exchange data.</p>
<p>Keep doing projects until <strong>Project #100</strong>.</p>
<p>You see, I build a project based on my previous project. Sometimes I had enough and decided to explore another interest (WiFi), and suddenly I can stack the existing projects (#6 and #7). Making it far more challenging than a simple blinking LED.</p>
<p>To use Project Stacking Method, you will need to hone your curiosity. Let your curiosity define your path and see what you can do with it.</p>
<p>Project Stacking Method isn't just for beginners trying to learn basic embedded concepts, it's also applicable to any level, including senior engineers. Though the topics will be very very different.</p>
<p>For example, seniors can do project like "<em>self-healing mesh network using Zigbee</em>". Or "<em>100% heapless C++ firmware development</em>". Or maybe "<em>AI-enabled smart home system where the AI can suggest electric bills optimization by observing usage pattern</em>" (okay I'm getting crazy here, but you got the idea).</p>
<p>I've been doing it for years, and my limitation now is actually time, not ideas. I'm married with one toddler son, so you probably understand how tricky it is to split time to work on side projects.</p>
<p>But if you have plenty of free time, you should really exploit it before you're getting married haha. üòÅ</p>
<p>PS: Send me a DM if you build a project. Probably I can give you my perspectives.</p>
<p>¬†</p>
            ]]>
        </content>
    </entry>
    <entry>
        <title>6 Real-World Embedded Projects to Learn From (Warning! Not For Beginners)</title>
        <author>
            <name>Rosmianto A. Saputro</name>
        </author>
        <link href="https://rosmianto.com/6-real-world-embedded-projects-to-learn-from-warning-not-for-beginners.html"/>
        <id>https://rosmianto.com/6-real-world-embedded-projects-to-learn-from-warning-not-for-beginners.html</id>
        <media:content url="https://rosmianto.com/media/posts/21/Screenshot-2024-04-06-at-20.49.23-2.png" medium="image" />
            <category term="Embedded Tips"/>

        <updated>2024-04-06T21:26:41+07:00</updated>
            <summary>
                <![CDATA[
                        <img src="https://rosmianto.com/media/posts/21/Screenshot-2024-04-06-at-20.49.23-2.png" alt="" />
                    Building real-world embedded products is hard. By real-world, I mean things you could use every day. Not some hackish product&hellip;
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                    <p><img src="https://rosmianto.com/media/posts/21/Screenshot-2024-04-06-at-20.49.23-2.png" class="type:primaryImage" alt="" /></p>
                <p>Building real-world embedded products is hard.</p>
<p>By real-world, I mean things you could use every day. Not some hackish product or just a Proof-of-Concept</p>
<p>I admit, it's hard because:<br><br>üëâ We don't know how to develop serious hardware design<br>üëâ We don't know how to write serious firmware<br>üëâ We don't know how to make a sleek enclosure<br>üëâ We lack of examples<br><br>That's why we need to look at how real-world projects are built.<br><br>The problem is, such projects are not easy to find.<br><br>Fortunately, I collect real-world projects like rich people collect watches.<br><br>Here are 6 real-world projects you could explore and learn, so you can understand the complexity of real-world projects.</p>
<h1>Numworks</h1>
<p>Numworks is a graphing calculator with sleek design and cool UI. The company released both the hardware and the firmware to make the product. It used by many students around the world.</p>
<figure class="post__image post__image--center"><img loading="lazy"  src="https://rosmianto.com/media/posts/21/Screenshot-2024-04-06-at-20.43.39.png" alt="" width="517" height="314" sizes="(min-width: 37.5em) 1600px, 80vw" srcset="https://rosmianto.com/media/posts/21/responsive/Screenshot-2024-04-06-at-20.43.39-xs.png 384w ,https://rosmianto.com/media/posts/21/responsive/Screenshot-2024-04-06-at-20.43.39-sm.png 600w ,https://rosmianto.com/media/posts/21/responsive/Screenshot-2024-04-06-at-20.43.39-md.png 768w ,https://rosmianto.com/media/posts/21/responsive/Screenshot-2024-04-06-at-20.43.39-lg.png 1200w ,https://rosmianto.com/media/posts/21/responsive/Screenshot-2024-04-06-at-20.43.39-xl.png 1600w"></figure>
<p>The device used to be hackable, meaning you could update the firmware to modify its features and capability (it has STM32 MCU so plenty of crazy stuff can be made).</p>
<p>Unfortunately, many schools and universities forbid hackable calculator (to prevent cheating), so Numworks company make it super-hard to update firmware.</p>
<p>But still, it's a cool project, I learned tons of electronics and firmware design from it. <a href="https://www.numworks.com/engineering/" target="_blank" rel="noopener noreferrer">Open here to view their tech specs, hardware, and software</a>.</p>
<h1>Clockwork GameShell</h1>
<p>GameShell is an open-source portable game console. It has a powerful specs. If you like playing Gameboy Advance, you will like it too.</p>
<figure class="post__image post__image--center"><img loading="lazy"  src="https://rosmianto.com/media/posts/21/Screenshot-2024-04-06-at-20.49.23.png" alt="" width="582" height="338" sizes="(min-width: 37.5em) 1600px, 80vw" srcset="https://rosmianto.com/media/posts/21/responsive/Screenshot-2024-04-06-at-20.49.23-xs.png 384w ,https://rosmianto.com/media/posts/21/responsive/Screenshot-2024-04-06-at-20.49.23-sm.png 600w ,https://rosmianto.com/media/posts/21/responsive/Screenshot-2024-04-06-at-20.49.23-md.png 768w ,https://rosmianto.com/media/posts/21/responsive/Screenshot-2024-04-06-at-20.49.23-lg.png 1200w ,https://rosmianto.com/media/posts/21/responsive/Screenshot-2024-04-06-at-20.49.23-xl.png 1600w"></figure>
<p>The enclosure is just, beautiful. It runs Linux so pretty easy to develop software on top of it.</p>
<p>Just checkout <a href="https://www.clockworkpi.com/gameshell" target="_blank" rel="noopener noreferrer">their website</a>. Also if you want to immediately see their software and hardware schematics, <a href="https://github.com/clockworkpi/GameShell" target="_blank" rel="noopener noreferrer">just click here</a> you nerdy!</p>
<h1>Gamebuino</h1>
<p>This is my first crush on a open hardware. I found this project from their kickstarter campaign years ago. Before further ado, let me show you this beauty:</p>
<figure ><figure class="post__image post__image--center"><img loading="lazy"  src="https://rosmianto.com/media/posts/21/Screenshot-2024-04-06-at-20.57.44.png" alt="" width="1000" height="459" sizes="(min-width: 37.5em) 1600px, 80vw" srcset="https://rosmianto.com/media/posts/21/responsive/Screenshot-2024-04-06-at-20.57.44-xs.png 384w ,https://rosmianto.com/media/posts/21/responsive/Screenshot-2024-04-06-at-20.57.44-sm.png 600w ,https://rosmianto.com/media/posts/21/responsive/Screenshot-2024-04-06-at-20.57.44-md.png 768w ,https://rosmianto.com/media/posts/21/responsive/Screenshot-2024-04-06-at-20.57.44-lg.png 1200w ,https://rosmianto.com/media/posts/21/responsive/Screenshot-2024-04-06-at-20.57.44-xl.png 1600w"></figure>
<figcaption >If you think this is ugly, we have different standard of beauty!</figcaption>
</figure>
<p>They don't open-sourced the hardware though, but <a href="https://github.com/Gamebuino/Gamebuino-META" target="_blank" rel="noopener noreferrer">their game API to make your own game</a> is valuable. They use ATSAMD21 as the microcontroller. The sickest feature is this console is able to rewriting the flash memory so we can load another new game.</p>
<p>I even ported <a href="https://github.com/rosmianto/gamebuino-esp32" target="_blank" rel="noopener noreferrer">Gamebuino software to work with ESP32</a>:</p>
<figure class="post__image post__image--center"><img loading="lazy"  src="https://rosmianto.com/media/posts/21/gamebuino-esp32.jpg" alt="" width="500" height="375" sizes="(min-width: 37.5em) 1600px, 80vw" srcset="https://rosmianto.com/media/posts/21/responsive/gamebuino-esp32-xs.jpg 384w ,https://rosmianto.com/media/posts/21/responsive/gamebuino-esp32-sm.jpg 600w ,https://rosmianto.com/media/posts/21/responsive/gamebuino-esp32-md.jpg 768w ,https://rosmianto.com/media/posts/21/responsive/gamebuino-esp32-lg.jpg 1200w ,https://rosmianto.com/media/posts/21/responsive/gamebuino-esp32-xl.jpg 1600w"></figure>
<h1>Odroid GO</h1>
<p>Another game console but using ESP32. What special about this device is you can emulate Gameboy, NES, Sega Master game using ESP32. If you want to learn about emulation and low-level optimization, check their <a href="https://github.com/hardkernel/ODROID-GO" target="_blank" rel="noopener noreferrer">GitHub repo</a>.</p>
<p>They open-sourced the hardware schematics and firmware.</p>
<figure class="post__image post__image--center"><img loading="lazy"  src="https://rosmianto.com/media/posts/21/68747470733a2f2f7777772e686172646b65726e656c2e636f6d2f6d61696e2f5f46696c65732f707264742f323031382f3230313830362f3230313830363132303633323139383431372e6a7067.jpg" alt="" width="482" height="468" sizes="(min-width: 37.5em) 1600px, 80vw" srcset="https://rosmianto.com/media/posts/21/responsive/68747470733a2f2f7777772e686172646b65726e656c2e636f6d2f6d61696e2f5f46696c65732f707264742f323031382f3230313830362f3230313830363132303633323139383431372e6a7067-xs.jpg 384w ,https://rosmianto.com/media/posts/21/responsive/68747470733a2f2f7777772e686172646b65726e656c2e636f6d2f6d61696e2f5f46696c65732f707264742f323031382f3230313830362f3230313830363132303633323139383431372e6a7067-sm.jpg 600w ,https://rosmianto.com/media/posts/21/responsive/68747470733a2f2f7777772e686172646b65726e656c2e636f6d2f6d61696e2f5f46696c65732f707264742f323031382f3230313830362f3230313830363132303633323139383431372e6a7067-md.jpg 768w ,https://rosmianto.com/media/posts/21/responsive/68747470733a2f2f7777772e686172646b65726e656c2e636f6d2f6d61696e2f5f46696c65732f707264742f323031382f3230313830362f3230313830363132303633323139383431372e6a7067-lg.jpg 1200w ,https://rosmianto.com/media/posts/21/responsive/68747470733a2f2f7777772e686172646b65726e656c2e636f6d2f6d61696e2f5f46696c65732f707264742f323031382f3230313830362f3230313830363132303633323139383431372e6a7067-xl.jpg 1600w"></figure>
<h1>ScopeFun</h1>
<p>Now something unrelated to game, an oscilloscope. Here you can learn about analog and digital signal processing at high-speed (500 MSps, mega-samples per second).</p>
<figure class="post__image post__image--center"><img loading="lazy"  src="https://rosmianto.com/media/posts/21/Screenshot-2024-04-06-at-21.16.07.png" alt="" width="557" height="322" sizes="(min-width: 37.5em) 1600px, 80vw" srcset="https://rosmianto.com/media/posts/21/responsive/Screenshot-2024-04-06-at-21.16.07-xs.png 384w ,https://rosmianto.com/media/posts/21/responsive/Screenshot-2024-04-06-at-21.16.07-sm.png 600w ,https://rosmianto.com/media/posts/21/responsive/Screenshot-2024-04-06-at-21.16.07-md.png 768w ,https://rosmianto.com/media/posts/21/responsive/Screenshot-2024-04-06-at-21.16.07-lg.png 1200w ,https://rosmianto.com/media/posts/21/responsive/Screenshot-2024-04-06-at-21.16.07-xl.png 1600w"></figure>You <a href="https://www.crowdsupply.com/scopefun/open-source-instrumentation" target="_blank" rel="noopener noreferrer">can buy it</a> or you can just learn it. <a href="https://gitlab.com/scopefun" target="_blank" rel="noopener noreferrer">Their GitLab repo</a> is well-organized. Very recommended to learn high-speed embedded project.</p>
<h1>Open-Smartwatch</h1>
<p>Lastly, an open-source smartwatch. Again, this project is built using ESP32 as the microcontroller. Apparently ESP32 is used in many serious projects (like <a href="https://www.mi.com/pk/mi-air-purifier-3c/" target="_blank" rel="noopener noreferrer">Xiaomi Air Purifier</a>, I know because I've done teardown of this hehe), not limited to hobbyist projects.</p>
<figure class="post__image post__image--center"><img loading="lazy"  src="https://rosmianto.com/media/posts/21/Open-Smartwatch.jpg" alt="" width="1000" height="400" sizes="(min-width: 37.5em) 1600px, 80vw" srcset="https://rosmianto.com/media/posts/21/responsive/Open-Smartwatch-xs.jpg 384w ,https://rosmianto.com/media/posts/21/responsive/Open-Smartwatch-sm.jpg 600w ,https://rosmianto.com/media/posts/21/responsive/Open-Smartwatch-md.jpg 768w ,https://rosmianto.com/media/posts/21/responsive/Open-Smartwatch-lg.jpg 1200w ,https://rosmianto.com/media/posts/21/responsive/Open-Smartwatch-xl.jpg 1600w"></figure>
<p>You can view the operating system, 3D files, hardware design on <a href="https://github.com/Open-Smartwatch" target="_blank" rel="noopener noreferrer">their GitHub repo</a>.</p>
<p>That's all folks. Happy tinkering!</p>
<p>¬†</p>
            ]]>
        </content>
    </entry>
    <entry>
        <title>2 Tips for Improving Your Firmware</title>
        <author>
            <name>Rosmianto A. Saputro</name>
        </author>
        <link href="https://rosmianto.com/2-tips-for-improving-your-firmware.html"/>
        <id>https://rosmianto.com/2-tips-for-improving-your-firmware.html</id>
        <media:content url="https://rosmianto.com/media/posts/19/c-m-iVfOFaEghqU-unsplash.jpg" medium="image" />
            <category term="Embedded Tips"/>

        <updated>2024-03-25T16:10:49+07:00</updated>
            <summary>
                <![CDATA[
                        <img src="https://rosmianto.com/media/posts/19/c-m-iVfOFaEghqU-unsplash.jpg" alt="" />
                    Josh is having a very bad day at work. He is a firmware engineer btw. ‚ÄúWtf? Boss wants 2 more&hellip;
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                    <p><img src="https://rosmianto.com/media/posts/19/c-m-iVfOFaEghqU-unsplash.jpg" class="type:primaryImage" alt="" /></p>
                <div>
<p>Josh is having a very bad day at work. He is a firmware engineer btw.<br><br>‚ÄúWtf? Boss wants 2 more features added to the firmware. Heck, I didn‚Äôt even fix my bug yesterday‚Äù He complained.<br><br>‚ÄúWhy? Aren‚Äôt those 2 features simple to implement?‚Äù I asked him.<br><br>‚ÄúEasier said than done! I need to touch maybe 20 files to do that. I‚Äôm afraid the code will break. It‚Äôs stressing me out!‚Äù He freaked out.<br><br>Here we can see the problem, well 3 problems:<br><br>‚Ä¢ Josh is struggling to add more features<br>‚Ä¢ Josh needs to touch tens of files to make small modifications<br>‚Ä¢ Josh is scared and not confident his work will be stable enough<br><br>Poor Josh. This thing shouldn‚Äôt be happening. Adding features shouldn‚Äôt be scary. In this article, I‚Äôm going to share 2 tips to kill Josh‚Äôs problems. But before we go through those tips, a few important notes:</p>
</div>
<div>
<ul>
<li>
<p>Improving your firmware means you need to improve your thinking. Because writing firmware is basically thinking in code</p>
</li>
<li>
<p>If you have too much hassle developing firmware, it means you need to either automate something or try another approach. Adding features should be straightforward (although not always easy, mind you)</p>
</li>
</ul>
</div>
<div>
<h2>Code Bloat ‚Üí Kill with Method Extraction</h2>
</div>
<div>
<p>Now, when Josh needed to add/change something, he had to modify his code in many locations. The code is similar (or even exactly the same), and he needed to use Ctrl+F to find everything.</p>
</div>
<div>
<p>This issue is called code duplication or code bloats. The solution is by extracting that similar code and create a function with appropriate parameters. For example, Josh has 2 similar code everywhere:</p>
</div>
<div>
<pre><code>// First code block
uint8_t payload[255] = ....;

uint8_t checksum = 0;
for (int i = 0; i &lt; 255; i++) {
    // Long code here..
    checksum = ....;
}</code></pre>
</div>
<div>
<pre><code>// Second code block
uint8_t payload[255] = ....;

uint8_t checksum = 0;
for (int i = 0; i &lt; 254; i++) {
    // Long code here..
    checksum = ....;
}</code></pre>
</div>
<div>
<p>Did you notice the difference between 1st vs 2nd code block?</p>
</div>
<div>
<p>Second block has 254, first block instead has 255. When I asked Josh, he said that the second block for some reason needs to exclude the last byte to calculate the checksum (Wtf Josh, that is dangerous!)</p>
</div>
<div>
<p>Now, those two blocks can be extracted and written into a single function:</p>
</div>
<div>
<pre><code>uint8_t calculateChecksum(uint8_t* payload, bool excludeLastByte) {
    
    uint8_t checksum = 0;
    uint8_t payloadSize = excludeLastByte ? 254 : 255;
    // Long code here...
}</code></pre>
</div>
<div>
<p>From there, we can calculate checksum simply by calling <code>calculateChecksum(payload, true)</code>.</p>
</div>
<div>
<h2>Insecure of Code Stability ‚Üí Kill with Unit Test</h2>
</div>
<div>
<p>We have reduced code bloats into a single function. And this gives us one more benefit: we can test it individually. By using unit test, we can ensure that the code is consistent and outputs the correct value as we expect.</p>
</div>
<div>
<p>Unit testing is basically calling <code>calculateChecksum()</code> with known payload, we compare the actual checksum with the expected value. If they match, we‚Äôre fine.</p>
</div>
<div>
<p>Remember that unit testing doesn‚Äôt necessarily use any testing framework like Catch2, Google Test. As long as you can verify the output, you‚Äôre doing unit tests (However, manual testing is painful as the code grows, that‚Äôs why we use testing framework, to do <strong><i>automated</i></strong><strong>¬†</strong>unit testing)</p>
</div>
<div>
<h2>Summary</h2>
</div>
<div>
<p>Use those 2 tips, and you will be better at dealing with code redundancy and feel confident in your firmware. If you want to explore more about this concept, we have plenty: Test-Driven Development (TDD), Modular programming, Assertion, etc.</p>
</div>
<div>
<p>Those topics are actually interconnected, so take your time to learn them all.</p>
</div>
            ]]>
        </content>
    </entry>
    <entry>
        <title>3 Essential Skills To Survive Embedded Career</title>
        <author>
            <name>Rosmianto A. Saputro</name>
        </author>
        <link href="https://rosmianto.com/3-essential-skills-to-survive-embedded-career.html"/>
        <id>https://rosmianto.com/3-essential-skills-to-survive-embedded-career.html</id>
        <media:content url="https://rosmianto.com/media/posts/18/venn.png" medium="image" />
            <category term="Embedded Career"/>

        <updated>2024-03-25T09:45:24+07:00</updated>
            <summary>
                <![CDATA[
                        <img src="https://rosmianto.com/media/posts/18/venn.png" alt="" />
                    Bob is an embedded software engineer, he thinks that writing well-crafted software is all he needs, so he learns and&hellip;
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                    <p><img src="https://rosmianto.com/media/posts/18/venn.png" class="type:primaryImage" alt="" /></p>
                <div>
<p>Bob is an embedded software engineer, he thinks that writing well-crafted software is all he needs, so he learns and practices:</p>
</div>
<div>
<ul>
<li>
<p>Clean and beautiful software architecture</p>
</li>
<li>
<p>Best design patterns and each use case</p>
</li>
<li>
<p>Algorithms for many problems</p>
</li>
</ul>
</div>
<div>
<p>While his software is beautiful and readable, he is also:</p>
</div>
<div>
<ul>
<li>
<p>Struggling to bring up a new development board his boss asked 2 weeks ago</p>
</li>
<li>
<p>Confused why the device he is working on cannot last long, even with a 10000mAh battery</p>
</li>
<li>
<p>Angry when the sensor is outputting messy data that breaks his algorithm</p>
</li>
</ul>
</div>
<div>
<p>Bob is a good and disciplined engineer, but his boss needs to hire Arjun, another embedded engineer to back him up.</p>
</div>
<div>
<p>Arjun believes that embedded software ‚â† computer software. Because embedded systems are a combination of hardware and software, he thinks that you need to understand electronics and software engineering to make things happen, fast (he‚Äôs right, you know).</p>
</div>
<div>
<p>But because he has weak software skills, the firmware he wrote is hard to maintain and unreadable. Arjun needs to consult a lot to Bob about modular firmware design, and coding best practices.</p>
</div>
<div>
<div>
<blockquote>
<p><i>Yeah, I solved the dev board and the battery issue. The messy output from sensor is because of unstable Vref and incorrect instrumentation op-amp choice. Bob sucks, I love working with him though.</i></p>
<p><span style="font-size: 0.790123em; font-family: var(--font-serif); color: var(--text-primary-color); font-weight: var(--font-weight-normal);">Arjun</span></p>
</blockquote>
</div>
</div>
<div>
<div>
<blockquote>
<p><i>Arjun‚Äôs code is a mess. We‚Äôre best friends now.</i></p>
<p><span style="font-size: 0.790123em; font-family: var(--font-serif); color: var(--text-primary-color); font-weight: var(--font-weight-normal);">Bob</span></p>
</blockquote>
</div>
</div>
<div>
<p>Now, while the story (and the quotes above) is 100% fabricated, I have seen and heard many similar stories: engineers struggle to move forward because of lack of basic understanding of electronics and software design.</p>
</div>
<div>
<p>To successfully work on Embedded Systems, you actually need 3 main skills:</p>
<p>üëâ Computer Science<br>üëâ Electrical Engineering<br>üëâ A third field depending on your interest</p>
</div>
<div>
<p>Take a look at this interesting diagram:</p>
<p>¬†</p>
</div>
<div><figure class="post__image post__image--center"><img loading="lazy"  src="https://rosmianto.com/media/posts/18/venn.avif" alt="" width="434" height="410"></figure></div>
<div>
<p>We need CS because there are programming aspects in Embedded Systems. We have to create robust, and efficient code for the device. Bob is the best example of this.<br><br>We need EE because we will be interfacing with electronic devices like sensors and actuators (thanks Arjun for solving the op-amp problem!).<br><br>Understanding the electronics under the hoods will make your life as an embedded engineer easy.<br><br>Lastly, we need a third field. It means that if we work on embedded devices on vehicles then we need to learn and understand automotive: its standards, the rules, the principles in auto.<br><br>The same with other fields.<br><br>I used to work in mining and marine, so I need to learn and understand how mining processes are done, how harsh the environment is, etc.</p>
</div>
<div>
<p>If we become just either Bob or Arjun, we are crippled.</p>
</div>
<div>
<p>If we become both Bob and Arjun, we are unstoppable.</p>
</div>
            ]]>
        </content>
    </entry>
    <entry>
        <title>Embedded Freelancers, Attract Not Hunt Clients</title>
        <author>
            <name>Rosmianto A. Saputro</name>
        </author>
        <link href="https://rosmianto.com/embedded-freelancer-attract-not-hunt-clients.html"/>
        <id>https://rosmianto.com/embedded-freelancer-attract-not-hunt-clients.html</id>
        <media:content url="https://rosmianto.com/media/posts/17/sebastian-herrmann-NbtIDoFKGO8-unsplash.jpg" medium="image" />
            <category term="Embedded Freelancing"/>

        <updated>2024-03-25T06:16:29+07:00</updated>
            <summary>
                <![CDATA[
                        <img src="https://rosmianto.com/media/posts/17/sebastian-herrmann-NbtIDoFKGO8-unsplash.jpg" alt="" />
                    I've been doing freelance as an embedded since 2021. and I realize one of the important things: There are simply&hellip;
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                    <p><img src="https://rosmianto.com/media/posts/17/sebastian-herrmann-NbtIDoFKGO8-unsplash.jpg" class="type:primaryImage" alt="" /></p>
                <p>I've been doing freelance as an embedded since 2021.</p>
<p>and I realize one of the important things:</p>
<p>There are simply too many project owners struggling to get freelancers. Yes, you read it right. We need more qualified embedded freelancers.</p>
<p>Many project owners send me DM offering projects, but I have to politely decline because of these 2:</p>
<ul>
<li>Their projects industry isn't aligned with my interests</li>
<li>I can't refer them to anybody because my freelance circle's interests are too similar to mine</li>
</ul>
<p>Okay, let's dig deeper into each point.</p>
<h3>Their projects industry isn't aligned with my interests</h3>
<p>My primary interests in embedded systems are low-power devices, wearables, portable devices, and things similar to those.</p>
<p>But sometimes I get this type of DM on LinkedIn:</p>
<figure class="post__image post__image--center"><img loading="lazy"  src="https://rosmianto.com/media/posts/17/Screenshot-2024-03-25-at-05.40.47.png" alt="" width="500" height="152" sizes="(min-width: 37.5em) 1600px, 80vw" srcset="https://rosmianto.com/media/posts/17/responsive/Screenshot-2024-03-25-at-05.40.47-xs.png 384w ,https://rosmianto.com/media/posts/17/responsive/Screenshot-2024-03-25-at-05.40.47-sm.png 600w ,https://rosmianto.com/media/posts/17/responsive/Screenshot-2024-03-25-at-05.40.47-md.png 768w ,https://rosmianto.com/media/posts/17/responsive/Screenshot-2024-03-25-at-05.40.47-lg.png 1200w ,https://rosmianto.com/media/posts/17/responsive/Screenshot-2024-03-25-at-05.40.47-xl.png 1600w"></figure>I have zero clue about what DC001 is.</p>
<p>Apparently it is a protocol for high voltage charging (like 48v to 72v high).</p>
<p>Another potential client asked me to work on his automotive project, my task will be ensuring the system compliance with regulations and standards.</p>
<p>"I'm sorry man, but I know nothing about regulations," I said to him.</p>
<p>"Ah, no worries mate. Know anyone who qualified?" He asked me.</p>
<p>"Uhhm, I'm afraid I don't know anyone suitable. Really sorry"</p>
<p>"Oh very unfortunate, thanks mate!"</p>
<p>Okay, you might ask. Why would a client with an automotive project approach me?</p>
<p>Well, the answer is very obvious. He doesn't know anybody else! Notice his question above.</p>
<h3>I Can't Refer Them</h3>
<p>"You're hanging out with folks similar to yours". Yes, I couldn't agree more.</p>
<p>My circle of friends is pretty similar to mine: low-power, portable products, consumer electronics.</p>
<p>You know, the older you get, the smaller your circle will be. That also happens to my freelance friends. That's why I am active on LinkedIn, to expand my online friends.</p>
<p>Many followers asked me to refer projects to them, yes I've done that honestly.</p>
<p>But, how many of them are working with high-voltage embedded projects? Or know a lot about regulations and standards?</p>
<p>Even if they happen to know, how can I ensure they really know? They don't demonstrate their regulations and standards knowledge on LinkedIn.</p>
<p>Do you really expect me to refer my client to a random person I found on LinkedIn?</p>
<p>My reputation would be at stake.</p>
<p>"Well Rosmianto, you could ask them for their portfolio to assess their skills?"</p>
<p>Why wouldn't they just post it on their LinkedIn üòÇ</p>
<p>I'm not a recruiter. Vetting each person isn't an easy feat.</p>
<h1>Attract, Not Hunt Your Clients</h1>
<p>We need more qualified freelancers who actively demonstrate their knowledge.</p>
<p>You might be an expert, but if nobody knows, how could you land a client?</p>
<p>If you want to become an embedded freelancer, you want to plan long-term.</p>
<p>And reverse your question, from "<em>How to get freelance clients?</em>"</p>
<p>to "<em>How freelance clients easily find me?</em>"</p>
<p>Flipping that question will also flip your entire approach to acquiring clients.</p>
<p>You no longer "ask for project", you will start "inviting them to see your profile".</p>
<p>One of the easiest ways to start attracting clients?</p>
<p>Start showing off your skills on LinkedIn for 30 days straight.</p>
            ]]>
        </content>
    </entry>
    <entry>
        <title>2-Rule Method for Experimental Projects</title>
        <author>
            <name>Rosmianto A. Saputro</name>
        </author>
        <link href="https://rosmianto.com/2-rule-method-for-experimental-projects.html"/>
        <id>https://rosmianto.com/2-rule-method-for-experimental-projects.html</id>
        <media:content url="https://rosmianto.com/media/posts/15/100projects-2.jpeg" medium="image" />
            <category term="Embedded Productivity"/>

        <updated>2024-03-20T16:07:42+07:00</updated>
            <summary>
                <![CDATA[
                        <img src="https://rosmianto.com/media/posts/15/100projects-2.jpeg" alt="" />
                    The simplest way to 10x your embedded learning speed: Tons of experimental projects ‚Äî here‚Äôs why: Now let's delve into&hellip;
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                    <p><img src="https://rosmianto.com/media/posts/15/100projects-2.jpeg" class="type:primaryImage" alt="" /></p>
                <p>The simplest way to 10x your embedded learning speed:</p>
<p>Tons of experimental projects ‚Äî here‚Äôs why:</p>
<ul>
<li>Experimental projects will help you learn in isolation (an important concept)</li>
<li>They will act as training wheels</li>
<li>They can be reused as future project‚Äôs template</li>
</ul>
<p>Now let's delve into each one.</p>
<h1>They will help you learn in isolation</h1>
<p>Yes this is an important thing when learning. Learning in isolation means you learn¬†<em>one thing at a time</em>.</p>
<p>Building full-scale embedded projects, while it's also good, will expose you to too many things at once. Let's say you learn embedded by exploring Smartwatch firmware source code, you will have to learn heartbeat sensor code, timekeeping code, display code (very complex), code for Bluetooth LE, and tons of other moving parts. All at once.</p>
<p>That sounds overwhelming.</p>
<p>It's better to build a project for each concept you want to learn. For example:</p>
<ul>
<li>A project containing how to drive an OLED display</li>
<li>A project about how to broadcast Bluetooth LE advertisement payload</li>
<li>Another project for heartbeat sensor to understand heart <span class="ILfuVd" lang="en"><span class="hgKElc">arrhythmia</span></span> (I don't even know what that is lol)</li>
</ul>
<p>In summary, learning in isolation will help your brain manage stress and deliberately practice one thing in one project.</p>
<h1>They will act as training wheels</h1>
<p>The funny thing about experimental projects is that, you will soon feel more confident to learn the next thing.</p>
<p>For example, once you've experimented with BLE, next time you need to add BLE will feel effortless and smooth like butter.</p>
<p>Somehow now you know BLE GATT, GAP, various generic profiles, how to config advertisements, etc. This time you work faster, and better. You know the common errors that could show up, plus how to solve them. Weird, but now BLE felt natural for you.</p>
<p>Switch to another project, and you will learn much faster.</p>
<p>Actually, to your surprise, this is backed up by science. Just look at the drawing I made below:</p>
<figure class="post__image post__image--center"><img loading="lazy"  src="https://rosmianto.com/media/posts/15/learning-loop-2.jpeg" alt="" width="400" height="409" sizes="(min-width: 37.5em) 1600px, 80vw" srcset="https://rosmianto.com/media/posts/15/responsive/learning-loop-2-xs.jpeg 384w ,https://rosmianto.com/media/posts/15/responsive/learning-loop-2-sm.jpeg 600w ,https://rosmianto.com/media/posts/15/responsive/learning-loop-2-md.jpeg 768w ,https://rosmianto.com/media/posts/15/responsive/learning-loop-2-lg.jpeg 1200w ,https://rosmianto.com/media/posts/15/responsive/learning-loop-2-xl.jpeg 1600w"></figure>
<p>Apparently, learning embedded systems is all psychological.</p>
<h1>They can be reused as future project‚Äôs template</h1>
<p>Lastly, this is probably the best way to reuse your learning folders: by making them as templates.</p>
<p>That way, you don't even need to worry about various configurations, you just copy and paste. And voila! You have added a new feature.</p>
<p>For example, in your BLE project before, you already made a BLE profile for Heart rate sensor, next time you need BLE with a heart rate sensor, you could just pull the folder and clone it. It will probably take 5 minutes (instead of redoing the same shit for 45 minutes, big win!).</p>
<h1>The 2-Rule Method</h1>
<p>All the above sounds easy, but to make it effective, there are lots of nuances to understand before you do it.</p>
<p>I created a 4-Rule Method to help you create experimental projects far more effectively.</p>
<h2>Rule #1: Aim for 100 Side Projects</h2>
<p>Part of being an excellent embedded engineer is just mere exposure. Create at least 100 side projects for 100 concepts you want to learn.</p>
<p>Yes, it seems daunting at first. But 100 projects are actually achievable if you learn lots of things.</p>
<p>Create a new project to learn how to interface a sensor with I2C.</p>
<p>Create a new project to convert analog signal into digital signal using ADC.</p>
<p>Create projects for different microcontrollers.</p>
<p>Make sure you understand each project, each line, and each configuration. Don't just blindly copy-paste code online because it will defeat the purpose of experimentation.</p>
<p>Look at my experiment folder:</p>
<figure ><figure class="post__image post__image--center"><img loading="lazy"  src="https://rosmianto.com/media/posts/15/100projects.jpeg" alt="" width="700" height="437" sizes="(min-width: 37.5em) 1600px, 80vw" srcset="https://rosmianto.com/media/posts/15/responsive/100projects-xs.jpeg 384w ,https://rosmianto.com/media/posts/15/responsive/100projects-sm.jpeg 600w ,https://rosmianto.com/media/posts/15/responsive/100projects-md.jpeg 768w ,https://rosmianto.com/media/posts/15/responsive/100projects-lg.jpeg 1200w ,https://rosmianto.com/media/posts/15/responsive/100projects-xl.jpeg 1600w"></figure>
<figcaption >Different MCU. Different sensor. Different projects. I'm more freestyle.</figcaption>
</figure>
<p>I have plenty of reusable projects in my stash.</p>
<h2>Rule #2: Ditch best practices</h2>
<p>Except you are experimenting with best practices, please ditch best practices, for now. The goal is to exposure to lots of things, including bad, stupid, dumb practices. You don't learn just from good things, but also from bad things.</p>
<p>Should you host the project on GitHub? Up to you.</p>
<p>Should you use Arduino or mbed? I don't know.</p>
<p>Even better, keep breaking rules in embedded systems to see how far you can abuse the project. Pick bad variable name, create 10000 lines main.cpp, try to overflow buffer. What happens if you don't draw diagram first.</p>
<p>You will learn something. And you will learn why such things are considered bad in the first place.</p>
<p class="msg msg--warning">Ditch the rules in experimental mode. But use all the best practices you know <strong>at work</strong>.</p>
<h2>Bonus Rule: Prioritize Quantity over Quality</h2>
<p>Yes, you read it right.</p>
<p>You should prioritize quantity over quality. Because quality work comes from lots of repetition. How do you think Tiger Woods perfected his swings?</p>
<p>Don't be too afraid of low-quality side projects, nobody will see them anyway.</p>
<p>Trust me, the quality will follow later. Focus on quantity first. Let me remind you of this quote:</p>
<blockquote>
<p>90% of everything is crap</p>
<p>Sturgeon's law</p>
</blockquote>
<p><!-- notionvc: 9aa7c0ef-d8e0-4b26-bec4-22b9b4d2972b --></p>
            ]]>
        </content>
    </entry>
    <entry>
        <title>3D Method for Confident Firmware</title>
        <author>
            <name>Rosmianto A. Saputro</name>
        </author>
        <link href="https://rosmianto.com/3d-method-for-confident-firmware.html"/>
        <id>https://rosmianto.com/3d-method-for-confident-firmware.html</id>
        <media:content url="https://rosmianto.com/media/posts/13/fwguide-2.webp" medium="image" />
            <category term="Embedded Productivity"/>

        <updated>2024-03-19T13:14:02+07:00</updated>
            <summary>
                <![CDATA[
                        <img src="https://rosmianto.com/media/posts/13/fwguide-2.webp" alt="" />
                    Sometimes you just feel that your firmware isn't robust enough, isn't reliable enough. What if my firmware isn't handling edge&hellip;
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                    <p><img src="https://rosmianto.com/media/posts/13/fwguide-2.webp" class="type:primaryImage" alt="" /></p>
                <p>Sometimes you just feel that your firmware isn't robust enough, isn't reliable enough. What if my firmware isn't handling edge cases very well?</p>
<p>First of all, I admire your concerns, because if you really think that way, that means you have a high standard when it comes to firmware development, really.</p>
<p>Because the majority of embedded engineers aren't even aware that their firmware should be robust and reliable. For them, as long as the firmware isn't crashing after 5 minutes of running, it's good and they move on to implement the next cool things.</p>
<p>That's very wrong on so many levels.</p>
<p>The firmware should be well-tested and you should understand every line of code you've written. The firmware should meet the requirements, and pass the performance threshold. For me, such firmware is called <em><strong>confident firmware</strong></em>.</p>
<p>You can be reasonably confident that your work is good enough to survive common scenarios and some special edge cases. Make no mistake, because confident firmware isn't equal to bug-free firmware. But whenever the firmware has bugs, you can <a href="https://rosmianto.com/git-backtracking-debugging-technique.html" target="_blank" rel="noopener noreferrer">confidently pinpoint</a> the root cause and immediately fix the issue.</p>
<p>The unsure feeling you have can be eliminated (or at least reduced) when you know everything about the firmware you develop, this is including:</p>
<ol>
<li>how each module interacts with the others</li>
<li>how each module has been tested</li>
<li>how each module is written</li>
</ol>
<p>That's why I call my method as <strong>3D Method: Draw, Dissect, Detect</strong>.</p>
<h1>3D: Draw, Dissect, Detect</h1>
<p>Now, let's delve into each step:</p>
<h2>Draw</h2>
<p>Every great software should have at least one diagram to explain the interaction between modules.</p>
<p>Humans, by nature, cannot comprehend chaos and complexity. That's why we invented maps to navigate the road, that's why we created organizational diagrams to show who is responsible for what.</p>
<p>In other words, we create abstraction to help ourselves manage chaos and complexity.</p>
<p>When it comes to firmware development, that means we draw firmware architecture diagrams, program flow diagrams, and hardware design diagrams. In my <a href="https://fwguide.rosmianto.com/" target="_blank" rel="noopener noreferrer">paid firmware development guide</a>, I explain more deeply how you can draw diagram for your embedded project. Here's an example of a firmware architecture diagram I've drawn for the guide:</p>
<figure ><figure class="post__image post__image--center"><img loading="lazy"  src="https://rosmianto.com/media/posts/13/fwguide.webp" alt="" width="700" height="570" sizes="(min-width: 37.5em) 1600px, 80vw" srcset="https://rosmianto.com/media/posts/13/responsive/fwguide-xs.webp 384w ,https://rosmianto.com/media/posts/13/responsive/fwguide-sm.webp 600w ,https://rosmianto.com/media/posts/13/responsive/fwguide-md.webp 768w ,https://rosmianto.com/media/posts/13/responsive/fwguide-lg.webp 1200w ,https://rosmianto.com/media/posts/13/responsive/fwguide-xl.webp 1600w"></figure>
<figcaption >Architecture diagram will help you navigate your firmware complexity (fwguide.rosmianto.com)</figcaption>
</figure>
<p>If you mastered the Draw step, you will be far more confident in your firmware design. You know which parts will do A, which part will do B, etc. Even if your project has bugs, you will immediately know where to look.</p>
<h2>Dissect</h2>
<p>Dissecting your code, or reviewing your code, is a sure way to make sure the firmware will work as intended. Sometimes you can do it alone, or you can ask your senior or even junior engineers to help dissect/review your code. Because as Linus Torvalds said:</p>
<blockquote>
<p>given enough eyeballs, all bugs are shallow</p>
<p>Linus's Law</p>
</blockquote>
<p>Yes, the more reviews, the more bugs can be discovered earlier.</p>
<p>If you think reviewing code is a tedious process, you are right, but you are also a bit wrong. Because I didn't say only humans can review your code. Sometimes robots (aka software) can help you catch silly mistakes here and there.</p>
<p>A good example of this robot is <a href="https://clang-analyzer.llvm.org/" target="_blank" rel="noopener noreferrer">static analyzer</a>. It's software that scans your entire firmware code to find some potential issues, sometimes it spits false-positive issues, but often it catches serious mistakes (like vulnerabilities or semantical errors).</p>
<p>So, use both humans and robots to maximize <span style="text-decoration: line-through;">profit</span> confidence.</p>
<h2>Detect</h2>
<p>Detect problems by testing your firmware code.</p>
<p>This can be achieved by writing unit tests, where you test each module with a set of inputs and expect certain outputs.</p>
<p>Testing can be automated. In fact, code testing should be automated. You can achieve this by using automation tools like GitHub Actions, so whenever you push changes to GitHub, it will automatically rerun the tests you've written, and report the result.</p>
<p>I recommend you to use <a href="https://github.com/catchorg/Catch2" target="_blank" rel="noopener noreferrer">Catch2</a>, because it is simple enough and easy enough to get started. Combine it with CMake and GitHub Actions, your life will be far easier. I cover this much deeper in my <a href="https://fwguide.rosmianto.com/" target="_blank" rel="noopener noreferrer">paid firmware guide</a>, I also give you a demo to setup GitHub Actions.</p>
<h1>Summary</h1>
<p>That's all to know. To make yourself more confident in your firmware, implement my 3D Method above and you will finally sleep better tonight.</p>
<p>Just remember that confidence doesn't guarantee bug-free, you still need to check and hunt for bugs. But at least, when you are confident, you can locate the issues much faster.</p>
            ]]>
        </content>
    </entry>
</feed>
